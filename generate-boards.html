<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Board Generator</title>
    <style>
        #status,
        #results {
            font-family: monospace;
        }
    </style>
</head>

<body style="font-family: sans-serif; margin: 1rem;">
    <label for="sizeSelect">Board Size:</label>
    <select id="sizeSelect"></select>

    <label style="margin-left:1rem;" for="boardSelect">Match Board:</label>
    <select id="boardSelect">
        <option value="none">None</option>
    </select>

    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <div style="margin-top: 1rem;">
        <div id="status" style="margin-bottom: 1rem; white-space: pre;"></div>
        <pre id="results"></pre>
    </div>
    <script type="module">
        import BOARD_LAYOUTS from './boards.js';

        const WORKER_COUNT = 16;
        const POPULATION_SIZE = 100;
        let running = false;
        let globalBestScore = -Infinity;
        let globalBestB1 = null;
        let globalBestB2 = null;
        let globalBestStats = null;
        let totalBoardsEvaluated = 0;
        let workers = [];
        let startTime = 0;

        // Gather unique board sizes from the layouts
        const uniqueSizes = [...new Set(
            Object.values(BOARD_LAYOUTS).map(layout => layout.grid.length)
        )].sort((a, b) => a - b);

        const sizeSelect = document.getElementById('sizeSelect');
        uniqueSizes.forEach(size => {
            const option = document.createElement('option');
            option.value = size;
            option.textContent = `${size}x${size}`;
            sizeSelect.appendChild(option);
        });

        function updateBoardOptions() {
            const size = parseInt(sizeSelect.value);
            const boardSelect = document.getElementById('boardSelect');
            boardSelect.innerHTML = '<option value="none">None</option>';

            // Only list boards that match the chosen size (excluding "Random" boards)
            Object.entries(BOARD_LAYOUTS).forEach(([id, layout]) => {
                if (layout.grid.length === size && !id.toLowerCase().includes('random')) {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = layout.name;
                    boardSelect.appendChild(option);
                }
            });
        }

        sizeSelect.addEventListener('change', updateBoardOptions);
        updateBoardOptions();

        function cyrb53(str, seed = 0) {
            let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^
                Math.imul(h2 ^ (h2 >>> 13), 3266489909);
            h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^
                Math.imul(h1 ^ (h1 >>> 13), 3266489909);
            return (4294967296 * (2097151 & h2) + (h1 >>> 0)) >>> 0;
        }

        // The worker code as a string
        const unifiedWorkerScript = `

// Return valid symbols for each board size
const getSymbolsForSize = (size) => {
    if (size === 4) return 'ABCDEFGHIJKLMNOP';
    if (size === 5) return 'ABCDEFGHIJKLMNOPQRSTUVWXY';
    if (size === 6) return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    if (size === 7) return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*+-=/?!~';
    return '';
};

let boardSize = 0;
let pinnedBoard = null;   // If a board is pinned, it remains b1
let evolving = false;
let boardsEvaluated = 0;
let bestScore = -Infinity;
let bestB1 = null;
let bestB2 = null;
let bestStats = null;
let population = [];

/**
 * Create a random board that uses all symbols for the given boardSize
 * but doesn't worry about dot positions (only used when pinnedBoard is NOT used).
 */
function randomFullBoard() {
    const boardLength = boardSize * boardSize;
    const symbols = getSymbolsForSize(boardSize).split('');
    const result = new Array(boardLength).fill('.');

    // Shuffle the symbol list
    for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
    }
    // Place them
    for (let i = 0; i < boardLength; i++) {
        if (i < symbols.length) result[i] = symbols[i];
    }
    return result;
}

/**
 * Create a new board that has exactly the same dot pattern as pinnedBoard
 * but the non-dot symbols are shuffled among those non-dot positions.
 */
function randomBoardMatchingPinned(pin) {
    const boardLength = boardSize * boardSize;
    // Copy pinned dot pattern
    const result = [...pin];  // just to get the same length
    // We'll gather all non-dot symbols
    const symbolPositions = [];
    const symbols = [];
    for (let i = 0; i < boardLength; i++) {
        if (pin[i] !== '.') {
            symbolPositions.push(i);
            symbols.push(pin[i]);
        } else {
            // keep the '.' in the result
            result[i] = '.';
        }
    }
    // Shuffle the collected symbols
    for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
    }
    // Put them back in the same non-dot positions
    for (let idx = 0; idx < symbolPositions.length; idx++) {
        result[symbolPositions[idx]] = symbols[idx];
    }
    return result;
}

// Returns true if board uses only valid symbols and no duplicates
function isValidBoard(board) {
    if (!board || board.length !== boardSize * boardSize) {
        return false;
    }
    const valid = getSymbolsForSize(boardSize);
    const seen = new Set();
    for (const ch of board) {
        if (ch === '.') continue;
        if (!valid.includes(ch) || seen.has(ch)) {
            return false;
        }
        seen.add(ch);
    }
    return true;
}

/**
 * The synergy/score function for boards.
 */
function evaluateBoards(b1, b2) {
    if (!isValidBoard(b1) || !isValidBoard(b2)) {
        return { score: -Infinity, moves: 0, stdev: 0, ratio: 0 };
    }

    function getTileScore(pos) {
        let score = 0;
        const row = Math.floor(pos / boardSize);
        const col = pos % boardSize;
        for (let r = 0; r < boardSize; r++) {
            for (let c = 0; c < boardSize; c++) {
                if (r === row && c === col) continue;
                const dist = Math.abs(row - r) + Math.abs(col - c);
                score += 1 / dist;
            }
        }
        return score;
    }

    const scores = [];
    // For each symbol in b1, see if it appears in b2
    for (let i = 0; i < b1.length; i++) {
        const symbol = b1[i];
        if (symbol === '.') continue;
        const j = b2.indexOf(symbol);
        if (j < 0) continue;
        scores.push(getTileScore(i) + getTileScore(j));
    }

    if (!scores.length) {
        return { score: -Infinity, moves: 0, stdev: 0, ratio: 0 };
    }

    const best = Math.max(...scores);
    const worst = Math.min(...scores);
    const sum = scores.reduce((a, b) => a + b, 0);
    const mean = sum / scores.length;
    const variance = scores.reduce((a, v) => a + (v - mean) ** 2, 0) / scores.length;
    const stdev = Math.sqrt(variance);
    const bestCount = scores.filter(x => Math.abs(x - best) < 1e-10).length;
    const ratio = worst / best;

    return {
        score: bestCount - stdev - ratio,
        moves: bestCount,
        stdev,
        ratio
    };
}

// Mutate a board by swapping a few pairs of non-dot symbols
function mutate(board) {
    if (!isValidBoard(board)) return board;
    const copy = [...board];
    const validPos = [];
    for (let i = 0; i < copy.length; i++) {
        if (copy[i] !== '.') validPos.push(i);
    }
    for (let s = 0; s < 2; s++) {
        const i1 = Math.floor(Math.random() * validPos.length);
        const i2 = Math.floor(Math.random() * validPos.length);
        const pos1 = validPos[i1];
        const pos2 = validPos[i2];
        [copy[pos1], copy[pos2]] = [copy[pos2], copy[pos1]];
    }
    return isValidBoard(copy) ? copy : board;
}

/**
 * Crossover for the second board. If pinnedBoard is used, we do NOT cross b1.
 */
function crossover(b2a, b2b) {
    if (!isValidBoard(b2a) || !isValidBoard(b2b)) return b2a;
    // We assume both have the same dot pattern as pinnedBoard, so let's do half from b2a, half from b2b
    const child = [...b2a];
    const validPositions = child.map((v, i) => (v !== '.' ? i : -1)).filter(i => i !== -1);
    const half = Math.floor(validPositions.length / 2);
    const used = new Set(b2a.filter(v => v !== '.').slice(0, half));

    let added = 0;
    for (const pos of validPositions) {
        if (added >= half) break;
        const symbol = b2b[pos];
        if (symbol === '.' || used.has(symbol)) continue;
        child[pos] = symbol;
        used.add(symbol);
        added++;
    }

    // Fill the leftover with any leftover symbols
    const fullSym = getSymbolsForSize(boardSize).split('');
    // Or we can gather from pinnedBoard, but if pinnedBoard has same set, it's the same
    const childSymbols = child.filter(ch => ch !== '.');
    const usedAll = new Set(childSymbols);
    const remain = fullSym.filter(ch => !usedAll.has(ch));
    for (const pos of validPositions) {
        if (child[pos] === '.' || !child[pos]) {
            child[pos] = remain.pop() || '.';
        }
    }

    return isValidBoard(child) ? child : b2a;
}

/**
 * Weighted random parent selection
 */
function pickParent(pop) {
    const totalScore = pop.reduce((sum, p) => sum + (p.stats.score + 50), 0);
    let r = Math.random() * totalScore;
    for (const item of pop) {
        r -= (item.stats.score + 50);
        if (r <= 0) return item;
    }
    return pop[pop.length - 1];
}

/**
 * Insert some random immigrants. 
 * If pinned board, randomizing b2 with the same dot layout.
 */
function insertImmigrants(pop) {
    const count = Math.max(1, Math.floor(pop.length * 0.05));
    for (let i = 0; i < count; i++) {
        const idx = Math.floor(Math.random() * pop.length);
        if (pinnedBoard) {
            // We keep pinnedBoard as b1
            const newB2 = randomBoardMatchingPinned(pinnedBoard);
            const stats = evaluateBoards(pinnedBoard, newB2);
            pop[idx] = { board1: pinnedBoard, board2: newB2, stats };
        } else {
            // old approach: random for both
            const b1 = randomFullBoard();
            const b2 = randomFullBoard();
            const stats = evaluateBoards(b1, b2);
            pop[idx] = { board1: b1, board2: b2, stats };
        }
    }
    return pop;
}

onmessage = (e) => {
    const data = e.data;
    if (data.msg === "start") {
        boardSize = data.boardSize;
        pinnedBoard = null;
        if (data.matchBoard && data.matchBoard.length) {
            pinnedBoard = data.matchBoard; // This is the pinned layout
        }
        evolving = true;
        boardsEvaluated = 0;
        bestScore = -Infinity;
        bestB1 = null;
        bestB2 = null;
        bestStats = null;
        population = [];

        // Initialize population
        for (let i = 0; i < ${POPULATION_SIZE}; i++) {
            let b1, b2;
            if (pinnedBoard) {
                // b1 is pinned
                b1 = [...pinnedBoard];
                // b2 is a random rearrangement that matches pinned's dots
                b2 = randomBoardMatchingPinned(pinnedBoard);
            } else {
                // No pinned board: random
                b1 = randomFullBoard();
                b2 = randomFullBoard();
            }
            const stats = evaluateBoards(b1, b2);
            population.push({ board1: b1, board2: b2, stats });
            if (stats.score > bestScore) {
                bestScore = stats.score;
                bestStats = stats;
                bestB1 = b1;
                bestB2 = b2;
            }
        }

        boardsEvaluated = ${POPULATION_SIZE};
        evolve();
    } else if (data.msg === "stop") {
        evolving = false;
    }
};

function evolve() {
    if (!evolving) return;

    for (let g = 0; g < 50; g++) {
        const newPop = [];
        for (let i = 0; i < ${POPULATION_SIZE}; i++) {
            let b1, b2, stats;
            if (pinnedBoard) {
                // pinned board is always b1
                b1 = [...pinnedBoard];
                const parent1 = pickParent(population);
                const parent2 = pickParent(population);
                // We do crossover for b2 only
                const x2 = crossover(parent1.board2, parent2.board2);
                b2 = mutate(x2);
                stats = evaluateBoards(b1, b2);
            } else {
                // old approach for both boards
                const p1 = pickParent(population);
                const p2 = pickParent(population);
                const x1 = crossover(p1.board1, p2.board1);
                const x2 = crossover(p1.board2, p2.board2);
                b1 = mutate(x1);
                b2 = mutate(x2);
                stats = evaluateBoards(b1, b2);
            }
            newPop.push({ board1: b1, board2: b2, stats });
            boardsEvaluated++;
            if (stats.score > bestScore) {
                bestScore = stats.score;
                bestStats = stats;
                bestB1 = b1;
                bestB2 = b2;
            }
        }
        population = insertImmigrants(newPop);
    }

    // Send progress
    if (bestScore > -Infinity) {
        postMessage({
            msg: 'progress',
            boardsEvaluated,
            bestScore,
            bestB1,
            bestB2,
            bestStats: {
                score: bestStats.score,
                moves: bestStats.moves,
                stdev: bestStats.stdev,
                ratio: bestStats.ratio
            }
        });
    } else {
        postMessage({
            msg: 'progress',
            boardsEvaluated
        });
    }
    if (evolving) {
        setTimeout(evolve, 0);
    }
}
`;

        // Create a blob from the worker script so we can spawn Worker instances
        const blob = new Blob([unifiedWorkerScript], { type: 'text/javascript' });
        const workerURL = URL.createObjectURL(blob);

        document.getElementById("startBtn").addEventListener("click", () => {
            if (running) return;

            const size = parseInt(sizeSelect.value);
            const boardId = boardSelect.value;
            let matchBoard = null;

            if (boardId !== 'none') {
                // Flatten the chosen board's 2D grid into a 1D array
                matchBoard = [];
                const layout = BOARD_LAYOUTS[boardId].grid;
                for (let i = 0; i < layout.length; i++) {
                    for (let j = 0; j < layout.length; j++) {
                        matchBoard.push(layout[i][j]);
                    }
                }
            }

            running = true;
            globalBestScore = -Infinity;
            globalBestB1 = null;
            globalBestB2 = null;
            globalBestStats = null;
            totalBoardsEvaluated = 0;
            startTime = performance.now();

            document.getElementById("results").textContent = "";
            document.getElementById("status").textContent = "Starting...";
            document.getElementById("stopBtn").disabled = false;
            document.getElementById("startBtn").disabled = true;

            workers = [];

            // Start the workers
            for (let i = 0; i < WORKER_COUNT; i++) {
                const worker = new Worker(workerURL);
                worker.onmessage = (evt) => {
                    const data = evt.data;
                    if (data.msg === "progress") {
                        // Average boards evaluated among all workers
                        totalBoardsEvaluated += (data.boardsEvaluated - totalBoardsEvaluated) / WORKER_COUNT;
                        if (data.bestScore > globalBestScore) {
                            globalBestScore = data.bestScore;
                            globalBestB1 = data.bestB1;
                            globalBestB2 = data.bestB2;
                            globalBestStats = data.bestStats;
                        }
                        updateStatus();
                    }
                };

                worker.postMessage({
                    msg: "start",
                    boardSize: size,
                    matchBoard: matchBoard
                });

                workers.push(worker);
            }
        });

        document.getElementById("stopBtn").addEventListener("click", () => {
            if (!running) return;
            running = false;
            for (const worker of workers) {
                worker.postMessage({ msg: "stop" });
            }
            document.getElementById("stopBtn").disabled = true;
            document.getElementById("startBtn").disabled = false;
        });

        /**
         * Generates a snippet for boards.js from the given boards.
         * If pinnedBoard is used, we only output the second board.
         */
        function generateBoardOutput(b1, b2, score, pinnedUsed) {
            const inputStr = b1.join("") + b2.join("") + score.toFixed(4);
            const hashedId = cyrb53(inputStr).toString();
            const size = Math.sqrt(b1.length);
            let out = "";

            if (!pinnedUsed) {
                // No pinned board: we produce 2 boards
                out += `board${hashedId}left: {\n`;
                out += `    name: "evolved left",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b1.slice(r * size, (r + 1) * size);
                    out += `        ['${row.join("', '")}'],\n`;
                }
                out += "    ]\n},\n";

                out += `board${hashedId}right: {\n`;
                out += `    name: "evolved right",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b2.slice(r * size, (r + 1) * size);
                    out += `        ['${row.join("', '")}'],\n`;
                }
                out += "    ]\n},\n";
            } else {
                // If pinned board: only produce the second board
                out += `board${hashedId}only: {\n`;
                out += `    name: "evolved second",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b2.slice(r * size, (r + 1) * size);
                    out += `        ['${row.join("', '")}'],\n`;
                }
                out += "    ]\n},\n";
            }

            return out;
        }

        function formatBoard(board, size) {
            let result = '';
            for (let r = 0; r < size; r++) {
                result += '    ';
                for (let c = 0; c < size; c++) {
                    result += board[r * size + c].padEnd(2);
                }
                result += '\n';
            }
            return result;
        }

        function updateStatus() {
            const now = performance.now();
            const elapsedSec = (now - startTime) / 1000;
            const boardsPerSec = elapsedSec > 0 ? totalBoardsEvaluated / elapsedSec : 0;
            const pinnedUsed = (boardSelect.value !== 'none');

            let status = `Time Elapsed: ${elapsedSec.toFixed(2)}s\n`;
            status += `Boards Evaluated (approx): ${Math.floor(totalBoardsEvaluated)}\n`;
            status += `Avg Boards/sec: ${boardsPerSec.toFixed(2)}\n`;
            status += `Global Best Score: ${globalBestScore.toFixed(4)}\n\n`;

            if (globalBestStats) {
                status += `Combined Score: ${globalBestStats.score.toFixed(2)}\n`;
                status += `Viable Moves: ${globalBestStats.moves}\n`;
                status += `Standard Deviation: ${globalBestStats.stdev.toFixed(2)}\n`;
                status += `Best/Worst Ratio: ${globalBestStats.ratio.toFixed(2)}\n\n`;

                if (globalBestB1 && globalBestB2) {
                    const size = Math.sqrt(globalBestB1.length);
                    // Pinned board is always b1 if pinnedUsed
                    status += 'Current best board(s):\n\n';

                    // Show pinned board only if pinnedUsed is false 
                    // or if you want to see it in debug form, you can always show it
                    if (!pinnedUsed) {
                        status += 'Board 1:\n';
                        status += formatBoard(globalBestB1, size) + '\n';
                        status += 'Board 2:\n';
                        status += formatBoard(globalBestB2, size) + '\n';
                    } else {
                        // If pinned, b1 never changes, so let's just show b2:
                        status += 'Pinned Board (unchanged, for reference):\n';
                        status += formatBoard(globalBestB1, size) + '\n';
                        status += 'Evolved Board (Board 2):\n';
                        status += formatBoard(globalBestB2, size) + '\n';
                    }

                    // Output snippet for boards.js
                    status += '\nPaste into boards.js:\n\n';
                    status += generateBoardOutput(globalBestB1, globalBestB2, globalBestScore, pinnedUsed);
                }
            }

            document.getElementById("status").textContent = status;
        }
    </script>
</body>

</html>