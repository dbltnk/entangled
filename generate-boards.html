<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Board Generator</title>
    <style>
        #status,
        #results {
            font-family: monospace;
        }
    </style>
</head>

<body style="font-family: sans-serif; margin: 1rem;">
    <label for="sizeSelect">Board Size:</label>
    <select id="sizeSelect"></select>
    <label style="margin-left:1rem;" for="boardSelect">Match Board:</label>
    <select id="boardSelect">
        <option value="none">None</option>
    </select>
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <div style="margin-top: 1rem;">
        <div id="status" style="margin-bottom: 1rem; white-space: pre;"></div>
        <pre id="results"></pre>
    </div>
    <script type="module">
        import BOARD_LAYOUTS from './boards.js';

        const WORKER_COUNT = 16;
        const POPULATION_SIZE = 100;

        let running = false;
        let clockInterval = null;
        let startTime = 0;

        let globalBestScore = -Infinity;
        let globalBestB1 = null;
        let globalBestB2 = null;
        let globalBestStats = null;
        let totalBoardsEvaluated = 0;
        let workers = [];
        // Track how many boards each worker has evaluated
        let workerCounts = new Array(WORKER_COUNT).fill(0);

        // Gather unique board sizes
        const uniqueSizes = [...new Set(
            Object.values(BOARD_LAYOUTS).map(layout => layout.grid.length)
        )].sort((a, b) => a - b);

        const sizeSelect = document.getElementById('sizeSelect');
        uniqueSizes.forEach(size => {
            const option = document.createElement('option');
            option.value = size;
            option.textContent = `${size}x${size}`;
            sizeSelect.appendChild(option);
        });

        function updateBoardOptions() {
            const size = parseInt(sizeSelect.value);
            const boardSelect = document.getElementById('boardSelect');
            boardSelect.innerHTML = '<option value="none">None</option>';
            Object.entries(BOARD_LAYOUTS).forEach(([id, layout]) => {
                if (layout.grid.length === size && !id.toLowerCase().includes('random')) {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = layout.name;
                    boardSelect.appendChild(option);
                }
            });
        }

        sizeSelect.addEventListener('change', updateBoardOptions);
        updateBoardOptions();

        function cyrb53(str, seed = 0) {
            let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^
                Math.imul(h2 ^ (h2 >>> 13), 3266489909);
            h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^
                Math.imul(h1 ^ (h1 >>> 13), 3266489909);
            return (4294967296 * (2097151 & h2) + (h1 >>> 0)) >>> 0;
        }

        // Updated worker script to recompute BFS for every pair we evaluate
        const unifiedWorkerScript = `
let tileScores = [];

function precomputeTileScores(size) {
    tileScores = new Array(size * size).fill(0);
    for (let pos = 0; pos < size * size; pos++) {
        let s = 0;
        const row = Math.floor(pos / size);
        const col = pos % size;
        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                if (r === row && c === col) continue;
                const dist = Math.abs(row - r) + Math.abs(col - c);
                s += 1 / dist;
            }
        }
        tileScores[pos] = s;
    }
}

let distanceCache = null;

// BFS for a single board
function calculateDistancesFromPos(pos, size, board) {
    const distances = new Uint8Array(size * size).fill(255);
    const queue = [[pos, 0]];
    distances[pos] = 0;
    
    while (queue.length > 0) {
        const [curPos, dist] = queue.shift();
        const row = Math.floor(curPos / size);
        const col = curPos % size;
        
        const moves = [
            [row - 1, col],
            [row + 1, col],
            [row, col - 1],
            [row, col + 1]
        ];
        
        for (const [newRow, newCol] of moves) {
            if (newRow < 0 || newRow >= size || newCol < 0 || newCol >= size) continue;
            const newPos = newRow * size + newCol;
            // Only walk through actual symbol positions, treat dots as walls
            if (board[newPos] === '.' || distances[newPos] !== 255) continue;
            distances[newPos] = dist + 1;
            queue.push([newPos, dist + 1]);
        }
    }
    return distances;
}

// Recompute BFS for the actual boards being evaluated:
function precomputeDistances(size, board1, board2) {
    const totalSize = size * size;
    distanceCache = {
        board1: new Uint8Array(totalSize * totalSize),
        board2: new Uint8Array(totalSize * totalSize)
    };
    
    for (let pos = 0; pos < totalSize; pos++) {
        if (board1[pos] !== '.') {
            const distances = calculateDistancesFromPos(pos, size, board1);
            for (let toPos = 0; toPos < totalSize; toPos++) {
                distanceCache.board1[pos * totalSize + toPos] = distances[toPos];
            }
        }
        if (board2[pos] !== '.') {
            const distances = calculateDistancesFromPos(pos, size, board2);
            for (let toPos = 0; toPos < totalSize; toPos++) {
                distanceCache.board2[pos * totalSize + toPos] = distances[toPos];
            }
        }
    }
}

function getTileScore(pos) {
    return tileScores[pos];
}

const getSymbolsForSize = (size) => {
    if (size === 4) return 'ABCDEFGHIJKLMNOP';
    if (size === 5) return 'ABCDEFGHIJKLMNOPQRSTUVWXY';
    if (size === 6) return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    if (size === 7) return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*+-=/?!~';
    return '';
};

let boardSize = 0;
let pinnedBoard = null;
let evolving = false;
let boardsEvaluated = 0;
let bestScore = -Infinity;
let bestB1 = null;
let bestB2 = null;
let bestStats = null;
let population = [];

function randomFullBoard() {
    const boardLength = boardSize * boardSize;
    const symbols = getSymbolsForSize(boardSize).split('');
    const result = new Array(boardLength).fill('.');
    // Shuffle
    for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
    }
    // Fill
    for (let i = 0; i < boardLength; i++) {
        if (i < symbols.length) result[i] = symbols[i];
    }
    return result;
}

function randomBoardMatchingPinned(pin) {
    const boardLength = boardSize * boardSize;
    const result = [...pin];
    const symbolPositions = [];
    const symbols = [];
    for (let i = 0; i < boardLength; i++) {
        if (pin[i] !== '.') {
            symbolPositions.push(i);
            symbols.push(pin[i]);
        } else {
            result[i] = '.';
        }
    }
    // Shuffle pinned symbols
    for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
    }
    for (let idx = 0; idx < symbolPositions.length; idx++) {
        result[symbolPositions[idx]] = symbols[idx];
    }
    return result;
}

function isValidBoard(board) {
    if (!board || board.length !== boardSize * boardSize) {
        return false;
    }
    const valid = getSymbolsForSize(boardSize);
    const seen = new Set();
    for (const ch of board) {
        if (ch === '.') continue;
        if (!valid.includes(ch) || seen.has(ch)) {
            return false;
        }
        seen.add(ch);
    }
    return true;
}

function evaluateBoards(b1, b2) {
    if (!isValidBoard(b1) || !isValidBoard(b2)) {
        return {
            score: -Infinity,
            moves: 0,
            stdev: 0,
            ratio: 0,
            proximityPenalty: 0,
            proximityViolationsDirectBoth: [],
            proximityViolationsOneDist2: [],
            proximityViolationsDist2Both: []
        };
    }

    const scores = [];
    // Sum tile scores for matching symbols
    for (let i = 0; i < b1.length; i++) {
        const symbol = b1[i];
        if (symbol === '.') continue;
        const j = b2.indexOf(symbol);
        if (j < 0) continue;
        scores.push(getTileScore(i) + getTileScore(j));
    }

    if (!scores.length) {
        return {
            score: -Infinity,
            moves: 0,
            stdev: 0,
            ratio: 0,
            proximityPenalty: 0,
            proximityViolationsDirectBoth: [],
            proximityViolationsOneDist2: [],
            proximityViolationsDist2Both: []
        };
    }

    // Compute base metrics
    const best = Math.max(...scores);
    const worst = Math.min(...scores);
    const sum = scores.reduce((a, b) => a + b, 0);
    const mean = sum / scores.length;
    const variance = scores.reduce((a, v) => a + (v - mean) ** 2, 0) / scores.length;
    const stdev = Math.sqrt(variance);
    const bestCount = scores.filter(x => Math.abs(x - best) < 1e-10).length;
    const ratio = worst / best;

    function isDiagonal(pos1, pos2, size) {
        const row1 = Math.floor(pos1 / size);
        const col1 = pos1 % size;
        const row2 = Math.floor(pos2 / size);
        const col2 = pos2 % size;
        
        // Check if positions are diagonal to each other
        return Math.abs(row1 - row2) === 1 && Math.abs(col1 - col2) === 1;
    }

    const proximityViolationsDirectBoth = new Set();
    const proximityViolationsOneDist2 = new Set();
    const proximityViolationsDist2Both = new Set();
    let proximityPenalty = 0;

    for (let i = 0; i < b1.length; i++) {
        const symbol1 = b1[i];
        if (symbol1 === '.') continue;
        const j1 = b2.indexOf(symbol1);

        for (let k = i + 1; k < b1.length; k++) {
            const symbol2 = b1[k];
            if (symbol2 === '.') continue;
            const j2 = b2.indexOf(symbol2);

            // Check if directly adjacent (Manhattan distance 1)
            const isAdjacent1 = Math.abs(Math.floor(i / boardSize) - Math.floor(k / boardSize)) + 
                               Math.abs((i % boardSize) - (k % boardSize)) === 1;
            const isAdjacent2 = Math.abs(Math.floor(j1 / boardSize) - Math.floor(j2 / boardSize)) + 
                               Math.abs((j1 % boardSize) - (j2 % boardSize)) === 1;

            // Check if diagonal
            const isDiagonal1 = isDiagonal(i, k, boardSize);
            const isDiagonal2 = isDiagonal(j1, j2, boardSize);

            if (isAdjacent1 && isAdjacent2) {
                proximityPenalty += 4;
                proximityViolationsDirectBoth.add(symbol1);
                proximityViolationsDirectBoth.add(symbol2);
            }
            else if ((isAdjacent1 && isDiagonal2) || (isDiagonal1 && isAdjacent2)) {
                proximityPenalty += 1;
                proximityViolationsOneDist2.add(symbol1);
                proximityViolationsOneDist2.add(symbol2);
            }
            else if (isDiagonal1 && isDiagonal2) {
                proximityPenalty += 0.25;
                proximityViolationsDist2Both.add(symbol1);
                proximityViolationsDist2Both.add(symbol2);
            }
        }
    }

    // Final combined score
    return {
        score: bestCount - stdev - ratio - proximityPenalty,
        moves: bestCount,
        stdev,
        ratio,
        proximityPenalty,
        proximityViolationsDirectBoth: Array.from(proximityViolationsDirectBoth).sort(),
        proximityViolationsOneDist2: Array.from(proximityViolationsOneDist2).sort(),
        proximityViolationsDist2Both: Array.from(proximityViolationsDist2Both).sort()
    };
}

function mutate(board) {
    if (!isValidBoard(board)) return board;
    const copy = [...board];
    const validPos = [];
    for (let i = 0; i < copy.length; i++) {
        if (copy[i] !== '.') validPos.push(i);
    }
    // Swap 2 pairs of symbols
    for (let s = 0; s < 2; s++) {
        const i1 = Math.floor(Math.random() * validPos.length);
        const i2 = Math.floor(Math.random() * validPos.length);
        const pos1 = validPos[i1];
        const pos2 = validPos[i2];
        [copy[pos1], copy[pos2]] = [copy[pos2], copy[pos1]];
    }
    return isValidBoard(copy) ? copy : board;
}

function crossover(b2a, b2b) {
    if (!isValidBoard(b2a) || !isValidBoard(b2b)) return b2a;
    const child = [...b2a];
    const validPositions = child.map((v, i) => (v !== '.' ? i : -1)).filter(i => i !== -1);
    const half = Math.floor(validPositions.length / 2);
    const used = new Set(b2a.filter(v => v !== '.').slice(0, half));
    let added = 0;
    for (const pos of validPositions) {
        if (added >= half) break;
        const symbol = b2b[pos];
        if (symbol === '.' || used.has(symbol)) continue;
        child[pos] = symbol;
        used.add(symbol);
        added++;
    }
    const fullSym = getSymbolsForSize(boardSize).split('');
    const childSymbols = child.filter(ch => ch !== '.');
    const usedAll = new Set(childSymbols);
    const remain = fullSym.filter(ch => !usedAll.has(ch));
    for (const pos of validPositions) {
        if (child[pos] === '.' || !child[pos]) {
            child[pos] = remain.pop() || '.';
        }
    }
    return isValidBoard(child) ? child : b2a;
}

function pickParent(pop) {
    // Weighted pick by (score + 50) to keep positives
    const totalScore = pop.reduce((sum, p) => sum + (p.stats.score + 50), 0);
    let r = Math.random() * totalScore;
    for (const item of pop) {
        r -= (item.stats.score + 50);
        if (r <= 0) return item;
    }
    return pop[pop.length - 1];
}

function insertImmigrants(pop) {
    const count = Math.max(1, Math.floor(pop.length * 0.05));
    for (let i = 0; i < count; i++) {
        const idx = Math.floor(Math.random() * pop.length);
        if (pinnedBoard) {
            const newB2 = randomBoardMatchingPinned(pinnedBoard);
            const stats = evaluateBoards(pinnedBoard, newB2);
            pop[idx] = { board1: pinnedBoard, board2: newB2, stats };
        } else {
            const b1 = randomFullBoard();
            const b2 = randomFullBoard();
            const stats = evaluateBoards(b1, b2);
            pop[idx] = { board1: b1, board2: b2, stats };
        }
    }
    return pop;
}

onmessage = (e) => {
    const data = e.data;
    if (data.msg === "start") {
        boardSize = data.boardSize;
        precomputeTileScores(boardSize);
        pinnedBoard = null;
        if (data.matchBoard && data.matchBoard.length) {
            pinnedBoard = data.matchBoard;
        }
        evolving = true;
        boardsEvaluated = 0;
        bestScore = -Infinity;
        bestB1 = null;
        bestB2 = null;
        bestStats = null;
        population = [];

        // Initialize population
        for (let i = 0; i < ${POPULATION_SIZE}; i++) {
            let b1, b2;
            if (pinnedBoard) {
                b1 = [...pinnedBoard];
                b2 = randomBoardMatchingPinned(pinnedBoard);
            } else {
                b1 = randomFullBoard();
                b2 = randomFullBoard();
            }
            const stats = evaluateBoards(b1, b2);
            population.push({ board1: b1, board2: b2, stats });
            if (stats.score > bestScore) {
                bestScore = stats.score;
                bestStats = stats;
                bestB1 = b1;
                bestB2 = b2;
            }
        }
        boardsEvaluated = ${POPULATION_SIZE};
        evolve();
    } else if (data.msg === "stop") {
        evolving = false;
    }
};

function evolve() {
    if (!evolving) return;
    for (let g = 0; g < 50; g++) {
        const newPop = [];
        for (let i = 0; i < ${POPULATION_SIZE}; i++) {
            let b1, b2, stats;
            if (pinnedBoard) {
                b1 = [...pinnedBoard];
                const parent1 = pickParent(population);
                const parent2 = pickParent(population);
                const x2 = crossover(parent1.board2, parent2.board2);
                b2 = mutate(x2);
                stats = evaluateBoards(b1, b2);
            } else {
                const p1 = pickParent(population);
                const p2 = pickParent(population);
                const x1 = crossover(p1.board1, p2.board1);
                const x2 = crossover(p1.board2, p2.board2);
                b1 = mutate(x1);
                b2 = mutate(x2);
                stats = evaluateBoards(b1, b2);
            }
            newPop.push({ board1: b1, board2: b2, stats });
            boardsEvaluated++;
            if (stats.score > bestScore) {
                bestScore = stats.score;
                bestStats = stats;
                bestB1 = b1;
                bestB2 = b2;
            }
        }
        population = insertImmigrants(newPop);
    }
    // Post status
    if (bestScore > -Infinity) {
        postMessage({
            msg: 'progress',
            boardsEvaluated,
            bestScore,
            bestB1,
            bestB2,
            bestStats: {
                score: bestStats.score,
                moves: bestStats.moves,
                stdev: bestStats.stdev,
                ratio: bestStats.ratio,
                proximityPenalty: bestStats.proximityPenalty,
                proximityViolationsDirectBoth: bestStats.proximityViolationsDirectBoth,
                proximityViolationsOneDist2: bestStats.proximityViolationsOneDist2,
                proximityViolationsDist2Both: bestStats.proximityViolationsDist2Both
            }
        });
    } else {
        postMessage({
            msg: 'progress',
            boardsEvaluated
        });
    }
    if (evolving) {
        setTimeout(evolve, 0);
    }
}
`;

        const blob = new Blob([unifiedWorkerScript], { type: 'text/javascript' });
        const workerURL = URL.createObjectURL(blob);

        // 
        // NEW FUNCTION: updates ONLY the top line of the status text
        // to show the real-time clock, ignoring the rest of the content.
        //
        function updateClockOnly() {
            if (!running) return; // no-op if not running
            const now = performance.now();
            const elapsedSec = (now - startTime) / 1000;

            const statusEl = document.getElementById("status");
            const oldText = statusEl.textContent || "";
            const lines = oldText.split("\n");

            // Make sure there's at least one line
            if (lines.length === 0) {
                lines.push("");
            }

            // Overwrite the first line with the current time
            lines[0] = `Time Elapsed: ${elapsedSec.toFixed(2)}s`;

            // Reassemble the text
            statusEl.textContent = lines.join("\n");
        }

        function updateStatus() {
            const now = performance.now();
            const elapsedSec = (now - startTime) / 1000;
            const boardsPerSec = elapsedSec > 0 ? totalBoardsEvaluated / elapsedSec : 0;
            const pinnedUsed = (boardSelect.value !== 'none');

            // We'll build the entire status content from scratch
            // but remember: the clock will be overwritten by updateClockOnly()
            // in between Worker messages. That is okay; they won't conflict badly.
            let status = `Time Elapsed: ${elapsedSec.toFixed(2)}s\n`;
            status += `Boards Evaluated (approx): ${Math.floor(totalBoardsEvaluated)}\n`;
            status += `Avg Boards/sec: ${boardsPerSec.toFixed(2)}\n`;
            status += `Global Best Score: ${globalBestScore.toFixed(4)}\n\n`;
            if (globalBestStats) {
                status += `Combined Score: ${globalBestStats.score.toFixed(2)}\n`;
                status += `Viable Moves: ${globalBestStats.moves}\n`;
                status += `Standard Deviation: ${globalBestStats.stdev.toFixed(2)}\n`;
                status += `Best/Worst Ratio: ${globalBestStats.ratio.toFixed(2)}\n`;
                status += `Proximity Penalty: ${globalBestStats.proximityPenalty}\n`;

                const {
                    proximityViolationsDirectBoth,
                    proximityViolationsOneDist2,
                    proximityViolationsDist2Both
                } = globalBestStats;

                if (proximityViolationsDirectBoth.length > 0) {
                    status += `Proximity Violations (neighbours on both boards): ${proximityViolationsDirectBoth.join(', ')}\n`;
                }
                if (proximityViolationsOneDist2.length > 0) {
                    status += `Proximity Violations (neighbours on one board, diagonal on other): ${proximityViolationsOneDist2.join(', ')}\n`;
                }
                if (proximityViolationsDist2Both.length > 0) {
                    status += `Proximity Violations (diagonal on both boards): ${proximityViolationsDist2Both.join(', ')}\n`;
                }
                status += '\n';

                if (globalBestB1 && globalBestB2) {
                    const size = Math.sqrt(globalBestB1.length);
                    status += 'Current best board(s):\n\n';
                    if (!pinnedUsed) {
                        status += 'Board 1:\n';
                        status += formatBoard(globalBestB1, size) + '\n';
                        status += 'Board 2:\n';
                        status += formatBoard(globalBestB2, size) + '\n';
                    } else {
                        status += 'Pinned Board (unchanged, for reference):\n';
                        status += formatBoard(globalBestB1, size) + '\n';
                        status += 'Evolved Board (Board 2):\n';
                        status += formatBoard(globalBestB2, size) + '\n';
                    }
                    status += '\nPaste into boards.js:\n\n';
                    status += generateBoardOutput(globalBestB1, globalBestB2, globalBestScore, pinnedUsed);
                }
            }
            document.getElementById("status").textContent = status;
        }

        function generateBoardOutput(b1, b2, score, pinnedUsed) {
            const inputStr = b1.join("") + b2.join("") + score.toFixed(4);
            const hashedId = cyrb53(inputStr).toString();
            const size = Math.sqrt(b1.length);
            let out = "";
            if (!pinnedUsed) {
                out += `board${hashedId}left: {\n`;
                out += `    name: "evolved left",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b1.slice(r * size, (r + 1) * size);
                    out += `        [${row.map(x => "'" + x + "'").join(", ")}],\n`;
                }
                out += "    ]\n},\n";
                out += `board${hashedId}right: {\n`;
                out += `    name: "evolved right",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b2.slice(r * size, (r + 1) * size);
                    out += `        [${row.map(x => "'" + x + "'").join(", ")}],\n`;
                }
                out += "    ]\n},\n";
            } else {
                out += `board${hashedId}only: {\n`;
                out += `    name: "evolved second",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b2.slice(r * size, (r + 1) * size);
                    out += `        [${row.map(x => "'" + x + "'").join(", ")}],\n`;
                }
                out += "    ]\n},\n";
            }
            return out;
        }

        function formatBoard(board, size) {
            let result = '';
            for (let r = 0; r < size; r++) {
                result += '    ';
                for (let c = 0; c < size; c++) {
                    result += board[r * size + c].padEnd(2);
                }
                result += '\n';
            }
            return result;
        }

        document.getElementById("startBtn").addEventListener("click", () => {
            if (running) return;

            const size = parseInt(sizeSelect.value);
            const boardId = boardSelect.value;
            let matchBoard = null;
            if (boardId !== 'none') {
                matchBoard = [];
                const layout = BOARD_LAYOUTS[boardId].grid;
                for (let i = 0; i < layout.length; i++) {
                    for (let j = 0; j < layout.length; j++) {
                        matchBoard.push(layout[i][j]);
                    }
                }
            }

            running = true;
            startTime = performance.now();

            // Start the real-time clock updates every 200ms
            clockInterval = setInterval(updateClockOnly, 10);

            globalBestScore = -Infinity;
            globalBestB1 = null;
            globalBestB2 = null;
            globalBestStats = null;
            totalBoardsEvaluated = 0;

            document.getElementById("results").textContent = "";
            document.getElementById("status").textContent = "Starting...";
            document.getElementById("stopBtn").disabled = false;
            document.getElementById("startBtn").disabled = true;
            workers = [];
            workerCounts = new Array(WORKER_COUNT).fill(0);

            for (let i = 0; i < WORKER_COUNT; i++) {
                const worker = new Worker(workerURL);
                // For each worker, track boardsEvaluated separately and sum them
                worker.onmessage = (evt) => {
                    const data = evt.data;
                    if (data.msg === "progress") {
                        // Each worker updates its own count:
                        workerCounts[i] = data.boardsEvaluated;
                        totalBoardsEvaluated = workerCounts.reduce((a, b) => a + b, 0);

                        if (data.bestScore > globalBestScore) {
                            globalBestScore = data.bestScore;
                            globalBestB1 = data.bestB1;
                            globalBestB2 = data.bestB2;
                            globalBestStats = data.bestStats;
                        }
                        updateStatus(); // updates all lines
                    }
                };
                worker.postMessage({
                    msg: "start",
                    boardSize: size,
                    matchBoard: matchBoard
                });
                workers.push(worker);
            }
        });

        document.getElementById("stopBtn").addEventListener("click", () => {
            if (!running) return;
            running = false;

            // Stop the clock timer
            if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }

            for (const worker of workers) {
                worker.postMessage({ msg: "stop" });
            }
            document.getElementById("stopBtn").disabled = true;
            document.getElementById("startBtn").disabled = false;
        });
    </script>
</body>

</html>