<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Board Generator</title>
    <style>
        #status,
        #results {
            font-family: monospace;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #2196F3;
            color: white;
            font-size: 12px;
            cursor: help;
            margin-left: 0.5rem;
            vertical-align: middle;
            position: relative;
        }

        .info-tooltip {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0.75rem;
            width: max-content;
            max-width: 500px;
            min-width: 300px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 8px;
            color: #333;
            text-align: left;
            font-weight: normal;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .info-tooltip p {
            margin: 0 0 0.5rem 0;
            color: #333;
        }

        .info-tooltip ul {
            margin: 0;
            padding-left: 1.2rem;
            list-style-type: disc;
        }

        .info-tooltip li {
            margin-bottom: 0.25rem;
            color: #333;
        }

        .info-tooltip ul ul {
            margin: 0.25rem 0;
        }

        .info-tooltip h3 {
            margin: 0.5rem 0 0.25rem 0;
            font-size: 0.9rem;
        }

        .info-tooltip br+br {
            display: none;
        }

        .info-tooltip ol {
            margin: 0;
            padding-left: 1.2rem;
        }

        .info-tooltip ol ul {
            margin: 0.25rem 0;
        }

        .info-tooltip li:last-child {
            margin-bottom: 0;
        }

        .info-icon:hover .info-tooltip,
        .info-tooltip:hover {
            display: block;
        }

        h1 {
            font-size: 1.8rem;
            color: #333;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
        }
    </style>
</head>

<body style="font-family: sans-serif; margin: 1rem;">
    <h1>
        Board Generator
        <span class="info-icon">i
            <div class="info-tooltip">
                <p>This tool uses a genetic algorithm to evolve optimal board layouts. Here's how it works:</p>

                <h3>Scoring System</h3>
                <ul>
                    <li>
                        <strong>Position Scoring:</strong> Each tile scores based on path length to all reachable tiles:
                        <ul>
                            <li>Direct neighbors: 1/1 = 1.0 points</li>
                            <li>Two steps away: 1/2 = 0.5 points</li>
                            <li>Three steps away: 1/3 = 0.33 points</li>
                            <li>And so on for all reachable tiles</li>
                        </ul>
                        Example: A tile reaching 2 direct (2.0), 3 two-step (1.5), 4 three-step (1.33), etc. sums all
                        scores.
                    </li>
                    <li>
                        <strong>Viable Moves:</strong> Count of positions within 0.0000000001 of best score.
                        Example: Best=5.0, others=[4.9999999999, 4.9999999998, 4.0] â†’ 3 viable moves.
                    </li>
                    <li>
                        <strong>Standard Deviation:</strong> How much scores vary. Lower is better.
                        Example: [5.0, 4.9, 4.8] (good) vs [5.0, 3.0, 1.0] (bad).
                    </li>
                    <li>
                        <strong>Combined Score = Viable Moves - Standard Deviation</strong>
                        Example: 5 viable moves - 1.2 deviation = 3.8 score
                    </li>
                </ul>

                <h3>Evolution Process</h3>
                <ol>
                    <li>Start with 100 random boards</li>
                    <li>Each generation:
                        <ul>
                            <li>Score boards using above system</li>
                            <li>Best boards become parents</li>
                            <li>Mix parents + small mutations</li>
                            <li>Add 5% random boards</li>
                        </ul>
                    </li>
                    <li>Repeat until stopped</li>
                </ol>

                <p style="margin-top: 0.25rem; margin-bottom: 0;"><strong>Note:</strong> In matching mode, only the
                    second board evolves.</p>
            </div>
        </span>
    </h1>

    <label for="sizeSelect">Board Size:</label>
    <select id="sizeSelect"></select>
    <label style="margin-left:1rem;" for="boardSelect">Match Board:</label>
    <select id="boardSelect">
        <option value="none">None</option>
    </select>
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <div style="margin-top: 1rem;">
        <div id="status" style="margin-bottom: 1rem; white-space: pre;"></div>
        <pre id="results"></pre>
    </div>
    <script type="module">
        import BOARD_LAYOUTS from './boards.js';

        const WORKER_COUNT = 16;
        const POPULATION_SIZE = 100;

        let running = false;
        let clockInterval = null;
        let startTime = 0;

        let globalBestScore = -Infinity;
        let globalBestB1 = null;
        let globalBestB2 = null;
        let globalBestStats = null;
        let globalFastStats = null;
        let totalBoardsEvaluated = 0;
        let workers = [];
        let workerCounts = new Array(WORKER_COUNT).fill(0);

        // Gather unique board sizes
        const uniqueSizes = [...new Set(
            Object.values(BOARD_LAYOUTS).map(layout => layout.grid.length)
        )].sort((a, b) => a - b);

        const sizeSelect = document.getElementById('sizeSelect');
        uniqueSizes.forEach(size => {
            const option = document.createElement('option');
            option.value = size;
            option.textContent = `${size}x${size}`;
            if (size === 7) option.selected = true;
            sizeSelect.appendChild(option);
        });

        function updateBoardOptions() {
            const size = parseInt(sizeSelect.value);
            const boardSelect = document.getElementById('boardSelect');
            boardSelect.innerHTML = '<option value="none">None</option>';
            Object.entries(BOARD_LAYOUTS).forEach(([id, layout]) => {
                if (layout.grid.length === size && !id.toLowerCase().includes('random')) {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = layout.name;
                    if (id === 'donut1') option.selected = true;
                    boardSelect.appendChild(option);
                }
            });
        }

        sizeSelect.addEventListener('change', updateBoardOptions);
        updateBoardOptions();

        function cyrb53(str, seed = 0) {
            let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^
                Math.imul(h2 ^ (h2 >>> 13), 3266489909);
            h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^
                Math.imul(h1 ^ (h1 >>> 13), 3266489909);
            return (4294967296 * (2097151 & h2) + (h1 >>> 0)) >>> 0;
        }

        const unifiedWorkerScript = `
// Cache for path calculations with strict size limits
const MAX_CACHE_SIZE = 1000; // Reduced from 10000
const pathCache = new Map();

// More efficient cache key generation
function getBoardKey(grid, startRow, startCol) {
    // Only include the relevant quadrant of the board to reduce key size
    const size = Math.sqrt(grid.length);
    const radius = 3; // Only cache paths within reasonable distance
    const minRow = Math.max(0, startRow - radius);
    const maxRow = Math.min(size - 1, startRow + radius);
    const minCol = Math.max(0, startCol - radius);
    const maxCol = Math.min(size - 1, startCol + radius);
    
    let key = startRow + "," + startCol + ":";
    for (let r = minRow; r <= maxRow; r++) {
        for (let c = minCol; c <= maxCol; c++) {
            const idx = r * size + c;
            key += grid[idx];
        }
    }
    return key;
}

// Cache cleanup that runs more frequently
function cleanupCache() {
    if (pathCache.size > MAX_CACHE_SIZE) {
        const entries = Array.from(pathCache.entries());
        // Keep only 25% of entries to be more aggressive with cleanup
        const toKeep = entries.slice(0, MAX_CACHE_SIZE / 4);
        pathCache.clear();
        toKeep.forEach(([key, value]) => pathCache.set(key, value));
    }
}

// BFS pathfinding with optimized memory usage
function findShortestPath(startRow, startCol, grid) {
    const size = Math.sqrt(grid.length);
    const cacheKey = getBoardKey(grid, startRow, startCol);
    
    if (pathCache.has(cacheKey)) {
        return pathCache.get(cacheKey);
    }
    
    // Use Uint8Array for distances to reduce memory usage
    const distances = new Uint8Array(size * size).fill(255); // 255 represents Infinity
    const queue = [[startRow * size + startCol, 0]];
    distances[startRow * size + startCol] = 0;
    
    while (queue.length > 0) {
        const [curPos, dist] = queue.shift();
        if (dist >= 255) break; // Prevent overflow
        
        const row = Math.floor(curPos / size);
        const col = curPos % size;
        
        const moves = [
            [row - 1, col],
            [row + 1, col],
            [row, col - 1],
            [row, col + 1]
        ];
        
        for (const [newRow, newCol] of moves) {
            if (newRow < 0 || newRow >= size || newCol < 0 || newCol >= size) continue;
            const newPos = newRow * size + newCol;
            if (grid[newPos] === '.' || distances[newPos] !== 255) continue;
            distances[newPos] = dist + 1;
            queue.push([newPos, dist + 1]);
        }
    }
    
    // Only cache if we're within our size limit
    if (pathCache.size < MAX_CACHE_SIZE) {
        pathCache.set(cacheKey, distances);
    }
    
    return distances;
}

// Modified tile score calculation to handle Uint8Array distances
function getTilePathScore(pos, grid) {
    const size = Math.sqrt(grid.length);
    if (grid[pos] === '.') return 0;

    const row = Math.floor(pos / size);
    const col = pos % size;
    const distances = findShortestPath(row, col, grid);
    let score = 0;
    let validPaths = 0;

    for (let i = 0; i < grid.length; i++) {
        if (i === pos || grid[i] === '.') continue;
        const distance = distances[i];
        if (distance !== 255) { // 255 is our Infinity
            score += 1 / distance;
            validPaths++;
        }
    }

    const totalTiles = grid.filter(cell => cell !== '.').length - 1;
    if (validPaths < totalTiles) {
        score *= validPaths / totalTiles;
    }

    return score;
}

// Board generation and validation
const getSymbolsForSize = (size) => {
    if (size === 4) return 'ABCDEFGHIJKLMNOP';
    if (size === 5) return 'ABCDEFGHIJKLMNOPQRSTUVWXY';
    if (size === 6) return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    if (size === 7) return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*+-=/?!~';
    return '';
};

let boardSize = 0;
let pinnedBoard = null;
let evolving = false;
let boardsEvaluated = 0;
let bestScore = -Infinity;
let bestB1 = null;
let bestB2 = null;
let bestStats = null;
let population = [];

function isValidBoard(board) {
    if (!board || board.length !== boardSize * boardSize) {
        return false;
    }
    const valid = getSymbolsForSize(boardSize);
    const seen = new Set();
    for (const ch of board) {
        if (ch === '.') continue;
        if (!valid.includes(ch) || seen.has(ch)) {
            return false;
        }
        seen.add(ch);
    }
    return true;
}

function randomFullBoard() {
    const boardLength = boardSize * boardSize;
    const symbols = getSymbolsForSize(boardSize).split('');
    const result = new Array(boardLength).fill('.');
    // Shuffle
    for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
    }
    // Fill
    for (let i = 0; i < boardLength; i++) {
        if (i < symbols.length) result[i] = symbols[i];
    }
    return result;
}

function randomBoardMatchingPinned(pin) {
    const boardLength = boardSize * boardSize;
    const result = [...pin];
    const symbolPositions = [];
    const symbols = [];
    for (let i = 0; i < boardLength; i++) {
        if (pin[i] !== '.') {
            symbolPositions.push(i);
            symbols.push(pin[i]);
        } else {
            result[i] = '.';
        }
    }
    // Shuffle pinned symbols
    for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
    }
    for (let idx = 0; idx < symbolPositions.length; idx++) {
        result[symbolPositions[idx]] = symbols[idx];
    }
    return result;
}

function mutate(board) {
    if (!isValidBoard(board)) return board;
    const copy = [...board];
    const validPos = [];
    for (let i = 0; i < copy.length; i++) {
        if (copy[i] !== '.') validPos.push(i);
    }
    // Swap 2 pairs of symbols
    for (let s = 0; s < 2; s++) {
        const i1 = Math.floor(Math.random() * validPos.length);
        const i2 = Math.floor(Math.random() * validPos.length);
        const pos1 = validPos[i1];
        const pos2 = validPos[i2];
        [copy[pos1], copy[pos2]] = [copy[pos2], copy[pos1]];
    }
    return isValidBoard(copy) ? copy : board;
}

function crossover(b2a, b2b) {
    if (!isValidBoard(b2a) || !isValidBoard(b2b)) return b2a;
    const child = [...b2a];
    const validPositions = child.map((v, i) => (v !== '.' ? i : -1)).filter(i => i !== -1);
    const half = Math.floor(validPositions.length / 2);
    const used = new Set(b2a.filter(v => v !== '.').slice(0, half));
    let added = 0;
    for (const pos of validPositions) {
        if (added >= half) break;
        const symbol = b2b[pos];
        if (symbol === '.' || used.has(symbol)) continue;
        child[pos] = symbol;
        used.add(symbol);
        added++;
    }
    const fullSym = getSymbolsForSize(boardSize).split('');
    const childSymbols = child.filter(ch => ch !== '.');
    const usedAll = new Set(childSymbols);
    const remain = fullSym.filter(ch => !usedAll.has(ch));
    for (const pos of validPositions) {
        if (child[pos] === '.' || !child[pos]) {
            child[pos] = remain.pop() || '.';
        }
    }
    return isValidBoard(child) ? child : b2a;
}

function pickParent(pop) {
    // Weighted pick by (score + 50) to keep positives
    const totalScore = pop.reduce((sum, p) => sum + (p.stats.score + 50), 0);
    let r = Math.random() * totalScore;
    for (const item of pop) {
        r -= (item.stats.score + 50);
        if (r <= 0) return item;
    }
    return pop[pop.length - 1];
}

function insertImmigrants(pop) {
    const count = Math.max(1, Math.floor(pop.length * 0.05));
    for (let i = 0; i < count; i++) {
        const idx = Math.floor(Math.random() * pop.length);
        if (pinnedBoard) {
            const newB2 = randomBoardMatchingPinned(pinnedBoard);
            const stats = evaluateBoardsFast(pinnedBoard, newB2);
            pop[idx] = { board1: pinnedBoard, board2: newB2, stats };
        } else {
            const b1 = randomFullBoard();
            const b2 = randomFullBoard();
            const stats = evaluateBoardsFast(b1, b2);
            pop[idx] = { board1: b1, board2: b2, stats };
        }
    }
    return pop;
}

// Fast Manhattan distance scoring
function getManhattanScore(pos1, pos2, size) {
    const row1 = Math.floor(pos1 / size);
    const col1 = pos1 % size;
    const row2 = Math.floor(pos2 / size);
    const col2 = pos2 % size;
    return 1 / (1 + Math.abs(row1 - row2) + Math.abs(col1 - col2));
}

function getTileManhattanScore(pos, grid) {
    const size = Math.sqrt(grid.length);
    if (grid[pos] === '.') return 0;

    let score = 0;
    for (let i = 0; i < grid.length; i++) {
        if (i === pos || grid[i] === '.') continue;
        score += getManhattanScore(pos, i, size);
    }
    return score;
}

// Fast evaluation for evolution
function evaluateBoardsFast(b1, b2) {
    if (!isValidBoard(b1) || !isValidBoard(b2)) {
        return {
            score: -Infinity,
            moves: 0,
            stdev: 0
        };
    }

    const scores = [];
    for (let i = 0; i < b1.length; i++) {
        const symbol = b1[i];
        if (symbol === '.') continue;
        const j = b2.indexOf(symbol);
        if (j < 0) continue;
        const score1 = getTileManhattanScore(i, b1);
        const score2 = getTileManhattanScore(j, b2);
        scores.push({
            symbol,
            score: score1 + score2
        });
    }

    if (!scores.length) {
        return {
            score: -Infinity,
            moves: 0,
            stdev: 0
        };
    }

    scores.sort((a, b) => b.score - a.score);
    const best = scores[0].score;
    const mean = scores.reduce((sum, s) => sum + s.score, 0) / scores.length;
    const variance = scores.reduce((sum, s) => sum + Math.pow(s.score - mean, 2), 0) / scores.length;
    const stdev = Math.sqrt(variance);
    const epsilon = 1e-10;
    const viableMoves = scores.filter(s => Math.abs(s.score - best) < epsilon).length;

    return {
        score: viableMoves - stdev,
        moves: viableMoves,
        stdev: stdev
    };
}

// Thorough evaluation with pathfinding for final validation
function evaluateBoardsAccurate(b1, b2) {
    if (!isValidBoard(b1) || !isValidBoard(b2)) {
        return {
            score: -Infinity,
            moves: 0,
            stdev: 0
        };
    }

    const scores = [];
    for (let i = 0; i < b1.length; i++) {
        const symbol = b1[i];
        if (symbol === '.') continue;
        const j = b2.indexOf(symbol);
        if (j < 0) continue;
        const score1 = getTilePathScore(i, b1);
        const score2 = getTilePathScore(j, b2);
        scores.push({
            symbol,
            score: score1 + score2
        });
    }

    if (!scores.length) {
        return {
            score: -Infinity,
            moves: 0,
            stdev: 0
        };
    }

    scores.sort((a, b) => b.score - a.score);
    const best = scores[0].score;
    const mean = scores.reduce((sum, s) => sum + s.score, 0) / scores.length;
    const variance = scores.reduce((sum, s) => sum + Math.pow(s.score - mean, 2), 0) / scores.length;
    const stdev = Math.sqrt(variance);
    const epsilon = 1e-10;
    const viableMoves = scores.filter(s => Math.abs(s.score - best) < epsilon).length;

    return {
        score: viableMoves - stdev,
        moves: viableMoves,
        stdev: stdev
    };
}

let generationsSinceValidation = 0;
const VALIDATE_EVERY_N_GENERATIONS = 20; // Increased validation frequency

function evolve() {
    if (!evolving) return;
    for (let g = 0; g < 25; g++) {
        const newPop = [];
        for (let i = 0; i < ${POPULATION_SIZE}; i++) {
            let b1, b2, stats;
            if (pinnedBoard) {
                b1 = [...pinnedBoard];
                const parent1 = pickParent(population);
                const parent2 = pickParent(population);
                const x2 = crossover(parent1.board2, parent2.board2);
                b2 = mutate(x2);
                stats = evaluateBoardsFast(b1, b2);
            } else {
                const p1 = pickParent(population);
                const p2 = pickParent(population);
                const x1 = crossover(p1.board1, p2.board1);
                const x2 = crossover(p1.board2, p2.board2);
                b1 = mutate(x1);
                b2 = mutate(x2);
                stats = evaluateBoardsFast(b1, b2);
            }
            newPop.push({ board1: b1, board2: b2, stats });
            boardsEvaluated++;
            
            // Update best score only if better than current best
            if (stats.score > bestScore * 0.9) { // Check more candidates
                const accurateStats = evaluateBoardsAccurate(b1, b2);
                if (accurateStats.score > bestScore) {
                    bestScore = accurateStats.score;
                    bestStats = accurateStats;
                    bestB1 = b1;
                    bestB2 = b2;
                }
            }
            
            // Cleanup cache more frequently
            if (pathCache.size > MAX_CACHE_SIZE * 0.9) {
                cleanupCache();
            }
        }
        population = insertImmigrants(newPop);
        
        generationsSinceValidation++;
        if (generationsSinceValidation >= VALIDATE_EVERY_N_GENERATIONS) {
            generationsSinceValidation = 0;
            cleanupCache(); // Force cleanup before validation
            // Validate top 10% of population
            const sortedPop = [...population].sort((a, b) => b.stats.score - a.stats.score);
            const topCount = Math.max(1, Math.floor(population.length * 0.1));
            for (let i = 0; i < topCount; i++) {
                const individual = sortedPop[i];
                const accurateStats = evaluateBoardsAccurate(individual.board1, individual.board2);
                if (accurateStats.score > bestScore) {
                    bestScore = accurateStats.score;
                    bestStats = accurateStats;
                    bestB1 = individual.board1;
                    bestB2 = individual.board2;
                }
            }
        }
    }
    
    // Post status
    if (bestScore > -Infinity) {
        postMessage({
            msg: 'progress',
            boardsEvaluated,
            bestScore,
            bestB1,
            bestB2,
            bestStats: {
                score: bestStats.score,
                moves: bestStats.moves,
                stdev: bestStats.stdev
            },
            fastStats: evaluateBoardsFast(bestB1, bestB2)
        });
    } else {
        postMessage({
            msg: 'progress',
            boardsEvaluated
        });
    }

    if (evolving) {
        setTimeout(evolve, 0);
    }
}

onmessage = (e) => {
    const data = e.data;
    if (data.msg === "start") {
        boardSize = data.boardSize;
        pinnedBoard = null;
        if (data.matchBoard && data.matchBoard.length) {
            pinnedBoard = data.matchBoard;
        }
        evolving = true;
        boardsEvaluated = 0;
        bestScore = -Infinity;
        bestB1 = null;
        bestB2 = null;
        bestStats = null;
        population = [];

        // Initialize population
        for (let i = 0; i < ${POPULATION_SIZE}; i++) {
            let b1, b2;
            if (pinnedBoard) {
                b1 = [...pinnedBoard];
                b2 = randomBoardMatchingPinned(pinnedBoard);
            } else {
                b1 = randomFullBoard();
                b2 = randomFullBoard();
            }
            const stats = evaluateBoardsFast(b1, b2);
            population.push({ board1: b1, board2: b2, stats });
            if (stats.score > bestScore) {
                bestScore = stats.score;
                bestStats = stats;
                bestB1 = b1;
                bestB2 = b2;
            }
        }
        boardsEvaluated = ${POPULATION_SIZE};
        evolve();
    } else if (data.msg === "stop") {
        evolving = false;
    }
};
`;

        const blob = new Blob([unifiedWorkerScript], { type: 'text/javascript' });
        const workerURL = URL.createObjectURL(blob);

        // 
        // NEW FUNCTION: updates ONLY the top line of the status text
        // to show the real-time clock, ignoring the rest of the content.
        //
        function updateClockOnly() {
            if (!running) return; // no-op if not running
            const now = performance.now();
            const elapsedSec = (now - startTime) / 1000;

            const statusEl = document.getElementById("status");
            const oldText = statusEl.textContent || "";
            const lines = oldText.split("\n");

            // Make sure there's at least one line
            if (lines.length === 0) {
                lines.push("");
            }

            // Overwrite the first line with the current time
            lines[0] = `Time Elapsed: ${elapsedSec.toFixed(2)}s`;

            // Reassemble the text
            statusEl.textContent = lines.join("\n");
        }

        function updateStatus() {
            const now = performance.now();
            const elapsedSec = (now - startTime) / 1000;
            const boardsPerSec = elapsedSec > 0 ? totalBoardsEvaluated / elapsedSec : 0;
            const pinnedUsed = (boardSelect.value !== 'none');

            let status = `Time Elapsed: ${elapsedSec.toFixed(2)}s\n`;
            status += `Boards Evaluated (approx): ${Math.floor(totalBoardsEvaluated)}\n`;
            status += `Avg Boards/sec: ${boardsPerSec.toFixed(2)}\n`;
            status += `Global Best Score (Pathfinding): ${globalBestScore.toFixed(4)}\n\n`;

            if (globalBestStats) {
                status += `Pathfinding Evaluation:\n`;
                status += `Combined Score: ${globalBestStats.score.toFixed(2)}\n`;
                status += `Viable Moves: ${globalBestStats.moves}\n`;
                status += `Standard Deviation: ${globalBestStats.stdev.toFixed(2)}\n\n`;

                if (globalFastStats) {
                    status += `Manhattan Distance Evaluation:\n`;
                    status += `Combined Score: ${globalFastStats.score.toFixed(2)}\n`;
                    status += `Viable Moves: ${globalFastStats.moves}\n`;
                    status += `Standard Deviation: ${globalFastStats.stdev.toFixed(2)}\n\n`;
                }

                if (globalBestB1 && globalBestB2) {
                    const size = Math.sqrt(globalBestB1.length);
                    status += 'Current best board(s):\n\n';
                    if (!pinnedUsed) {
                        status += 'Board 1:\n';
                        status += formatBoard(globalBestB1, size) + '\n';
                        status += 'Board 2:\n';
                        status += formatBoard(globalBestB2, size) + '\n';
                    } else {
                        status += 'Pinned Board (unchanged, for reference):\n';
                        status += formatBoard(globalBestB1, size) + '\n';
                        status += 'Evolved Board (Board 2):\n';
                        status += formatBoard(globalBestB2, size) + '\n';
                    }
                    status += '\nPaste into boards.js:\n\n';
                    status += generateBoardOutput(globalBestB1, globalBestB2, globalBestScore, pinnedUsed);
                }
            }
            document.getElementById("status").textContent = status;
        }

        function generateBoardOutput(b1, b2, score, pinnedUsed) {
            const inputStr = b1.join("") + b2.join("") + score.toFixed(4);
            const hashedId = cyrb53(inputStr).toString();
            const size = Math.sqrt(b1.length);
            let out = "";
            if (!pinnedUsed) {
                out += `board${hashedId}left: {\n`;
                out += `    name: "evolved left",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b1.slice(r * size, (r + 1) * size);
                    out += `        [${row.map(x => "'" + x + "'").join(", ")}],\n`;
                }
                out += "    ]\n},\n";
                out += `board${hashedId}right: {\n`;
                out += `    name: "evolved right",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b2.slice(r * size, (r + 1) * size);
                    out += `        [${row.map(x => "'" + x + "'").join(", ")}],\n`;
                }
                out += "    ]\n},\n";
            } else {
                out += `board${hashedId}only: {\n`;
                out += `    name: "evolved second",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b2.slice(r * size, (r + 1) * size);
                    out += `        [${row.map(x => "'" + x + "'").join(", ")}],\n`;
                }
                out += "    ]\n},\n";
            }
            return out;
        }

        function formatBoard(board, size) {
            let result = '';
            for (let r = 0; r < size; r++) {
                result += '    ';
                for (let c = 0; c < size; c++) {
                    result += board[r * size + c].padEnd(2);
                }
                result += '\n';
            }
            return result;
        }

        document.getElementById("startBtn").addEventListener("click", () => {
            if (running) return;

            const size = parseInt(sizeSelect.value);
            const boardId = boardSelect.value;
            let matchBoard = null;
            if (boardId !== 'none') {
                matchBoard = [];
                const layout = BOARD_LAYOUTS[boardId].grid;
                for (let i = 0; i < layout.length; i++) {
                    for (let j = 0; j < layout.length; j++) {
                        matchBoard.push(layout[i][j]);
                    }
                }
            }

            running = true;
            startTime = performance.now();

            // Start the real-time clock updates every 200ms
            clockInterval = setInterval(updateClockOnly, 10);

            globalBestScore = -Infinity;
            globalBestB1 = null;
            globalBestB2 = null;
            globalBestStats = null;
            totalBoardsEvaluated = 0;

            document.getElementById("results").textContent = "";
            document.getElementById("status").textContent = "Starting...";
            document.getElementById("stopBtn").disabled = false;
            document.getElementById("startBtn").disabled = true;
            workers = [];
            workerCounts = new Array(WORKER_COUNT).fill(0);

            for (let i = 0; i < WORKER_COUNT; i++) {
                const worker = new Worker(workerURL);
                // For each worker, track boardsEvaluated separately and sum them
                worker.onmessage = (evt) => {
                    const data = evt.data;
                    if (data.msg === "progress") {
                        // Each worker updates its own count:
                        workerCounts[i] = data.boardsEvaluated;
                        totalBoardsEvaluated = workerCounts.reduce((a, b) => a + b, 0);

                        if (data.bestScore > globalBestScore) {
                            globalBestScore = data.bestScore;
                            globalBestB1 = data.bestB1;
                            globalBestB2 = data.bestB2;
                            globalBestStats = data.bestStats;
                            globalFastStats = data.fastStats;
                        }
                        updateStatus(); // updates all lines
                    }
                };
                worker.postMessage({
                    msg: "start",
                    boardSize: size,
                    matchBoard: matchBoard
                });
                workers.push(worker);
            }
        });

        document.getElementById("stopBtn").addEventListener("click", () => {
            if (!running) return;
            running = false;

            // Stop the clock timer
            if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }

            for (const worker of workers) {
                worker.postMessage({ msg: "stop" });
            }
            document.getElementById("stopBtn").disabled = true;
            document.getElementById("startBtn").disabled = false;
        });
    </script>
</body>

</html>