<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Board Generator</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 2rem;
            background: #f5f5f5;
            color: #333;
            min-width: 1200px;
            height: calc(100vh - 4rem);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .controls {
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        select,
        button {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        button {
            background: #fff;
            cursor: pointer;
            transition: all 0.2s;
            padding: 8px 16px;
        }

        button:not(:disabled):hover {
            background: #f0f0f0;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #startBtn {
            background: #2196F3;
            color: white;
            border: none;
        }

        #startBtn:not(:disabled):hover {
            background: #1976D2;
        }

        #stopBtn {
            background: #f44336;
            color: white;
            border: none;
        }

        #stopBtn:not(:disabled):hover {
            background: #d32f2f;
        }

        label {
            font-size: 0.9rem;
        }

        .results-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .status-card {
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            grid-column: 1;
            grid-row: 2;
        }

        .board-card {
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            align-items: center;
            flex: 1.35;
            position: relative;
        }

        .board-card.pinned {
            background: #f8f8f8;
        }

        .board-card .lock-icon {
            position: absolute;
            top: 1rem;
            left: 1rem;
            font-size: 1.2rem;
            color: #666;
            display: none;
        }

        .board-card.pinned .lock-icon {
            display: block;
        }

        .board-display {
            display: flex;
            gap: 2rem;
            justify-content: center;
            margin: 0;
            min-height: 0;
            overflow: hidden;
            will-change: transform;
            align-items: center;
            flex: 1;
        }

        .board {
            display: grid;
            gap: 1px;
            background: #ddd;
            padding: 1px;
            will-change: transform;
            backface-visibility: hidden;
            transform: translateZ(0);
            height: min-content;
        }

        .board-cell {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            position: relative;
            background: #fff;
            width: 35px;
            height: 35px;
            padding: 2px;
            transition: background-color 0.2s ease-out;
            will-change: transform, background-color;
            backface-visibility: hidden;
            transform: translateZ(0);
        }

        .board-cell .symbol {
            font-size: 1rem;
            font-weight: bold;
        }

        .board-cell .score {
            font-size: 0.65rem;
            font-weight: 500;
            line-height: 1.1;
        }

        .board-cell .individual-score {
            font-size: 0.6rem;
            font-weight: 400;
            opacity: 0.8;
            line-height: 1;
        }

        .results-card {
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            grid-column: span 2;
        }

        .board-output {
            position: relative;
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }

        .copy-section {
            flex: 1;
        }

        .copy-button {
            position: static;
            margin: 0;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            padding: 12px 24px;
            font-size: 1.1rem;
            flex: 1;
            min-height: 0;
            overflow: hidden;
            white-space: nowrap;
        }

        .copy-button:hover {
            background: #1976D2;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .copy-button.copied {
            background: #4CAF50;
        }

        #results {
            font-family: monospace;
            white-space: pre;
            background: #f8f8f8;
            padding: 1rem;
            border-radius: 4px;
            border: 1px solid #eee;
            overflow-y: auto;
            margin: 0;
            height: 200px;
        }

        .metrics {
            flex: 1;
            padding: 1rem;
            background: #f8f8f8;
            border-radius: 4px;
            border: 1px solid #eee;
        }

        #status {
            font-family: monospace;
            white-space: pre;
            line-height: 1.4;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
            padding: 0.3rem 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .status-label {
            font-weight: normal;
        }

        .status-value {
            font-weight: bold;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #2196F3;
            color: white;
            font-size: 12px;
            cursor: help;
            margin-left: 0.5rem;
            vertical-align: middle;
            position: relative;
        }

        .info-tooltip {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
            width: max-content;
            max-width: 500px;
            min-width: 300px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 8px;
            color: #333;
            text-align: left;
            font-weight: normal;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .info-tooltip p {
            margin: 0 0 0.5rem 0;
            color: #333;
        }

        .info-tooltip ul {
            margin: 0;
            padding-left: 1.2rem;
            list-style-type: disc;
        }

        .info-tooltip li {
            margin-bottom: 0.25rem;
            color: #333;
        }

        .info-icon:hover .info-tooltip,
        .info-tooltip:hover {
            display: block;
        }

        h1 {
            font-size: 1.8rem;
            color: #333;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
        }

        .loading-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: monospace;
            color: #666;
            font-size: 0.9rem;
            white-space: nowrap;
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            background: #f5f5f5;
            padding: 0.5rem 1rem;
            border-radius: 4px;
        }

        .loading-indicator.hidden {
            display: none;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
            padding: 0.3rem 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .metric-value {
            font-weight: bold;
        }

        .better-lower {
            color: #2196F3;
        }

        .better-higher {
            color: #4CAF50;
        }

        .control-group input[type="number"] {
            width: 4rem;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .code-card {
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            grid-column: 2;
            grid-row: 2;
            display: flex;
            flex-direction: column;
        }

        .copy-card {
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            grid-column: 3;
            grid-row: 2;
            display: flex;
            align-items: stretch;
            justify-content: stretch;
            min-height: 0;
            overflow: hidden;
        }

        .history-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: 1rem;
        }

        .history-nav {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .history-button {
            padding: 4px 8px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .history-button:not(:disabled):hover {
            background: #f0f0f0;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .history-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .history-status {
            font-size: 0.9rem;
            color: #666;
            white-space: nowrap;
        }

        .pinned-indicator {
            font-size: 0.8rem;
            color: #666;
            font-weight: normal;
            display: none;
        }

        .metrics-card {
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex: 1;
        }
    </style>
</head>

<body>
    <h1>
        Board Generator
        <span class="info-icon">i
            <div class="info-tooltip">
                <p>This tool uses a genetic algorithm to evolve optimal board layouts. Here's how it works:</p>

                <h3>Scoring System</h3>
                <ul>
                    <li>
                        <strong>Position Scoring:</strong> Each tile scores based on path length to all reachable tiles:
                        <ul>
                            <li>Direct neighbors: 1/1 = 1.0 points</li>
                            <li>Two steps away: 1/2 = 0.5 points</li>
                            <li>Three steps away: 1/3 = 0.33 points</li>
                            <li>And so on for all reachable tiles</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Viable Moves:</strong> Count of positions within 0.0000000001 of best score.
                    </li>
                    <li>
                        <strong>Standard Deviation:</strong> How much scores vary. Lower is better.
                    </li>
                    <li>
                        <strong>Combined Score = Viable Moves - Standard Deviation</strong>
                    </li>
                </ul>

                <h3>Evolution Process</h3>
                <ol>
                    <li>Start with 100 random boards</li>
                    <li>Each generation:
                        <ul>
                            <li>Score boards using above system</li>
                            <li>Best boards become parents</li>
                            <li>Mix parents + small mutations</li>
                            <li>Add 5% random boards</li>
                        </ul>
                    </li>
                    <li>Repeat until stopped</li>
                </ol>

                <p><strong>Note:</strong> In matching mode, only the second board evolves.</p>
            </div>
        </span>
        <div id="loadingIndicator" class="loading-indicator hidden">
            <div class="loading-status">Initializing...</div>
        </div>
    </h1>

    <div class="controls">
        <div class="control-group">
            <label for="sizeSelect">Board Size:</label>
            <select id="sizeSelect"></select>
        </div>
        <div class="control-group">
            <label for="boardSelect">Match Board:</label>
            <select id="boardSelect">
                <option value="none">None</option>
            </select>
        </div>
        <div class="control-group">
            <label for="workerCount">Workers:</label>
            <input type="number" id="workerCount" min="1" max="32" value="14" />
        </div>
        <div class="control-group">
            <button id="startBtn">Start Evolution</button>
            <button id="stopBtn" disabled>Stop</button>
            <div class="history-controls">
                <div class="history-nav">
                    <button class="history-button" id="prevBtn" disabled>â—€</button>
                    <button class="history-button" id="nextBtn" disabled>â–¶</button>
                </div>
                <span class="history-status" id="historyStatus">0 boards</span>
            </div>
        </div>
    </div>

    <div class="results-container">
        <div class="board-card" id="board1Card">
            <span class="lock-icon">ðŸ”’</span>
            <div id="board1Display" class="board-display"></div>
        </div>

        <div class="metrics-card">
            <div class="metrics-section">
                <h4>Pathfinding Evaluation</h4>
                <div class="metric-row">
                    <span>Combined Score:</span>
                    <span class="metric-value better-higher" id="combinedScore">-</span>
                </div>
                <div class="metric-row">
                    <span>Viable Moves:</span>
                    <span class="metric-value better-higher" id="viableMoves">-</span>
                </div>
                <div class="metric-row">
                    <span>Standard Deviation:</span>
                    <span class="metric-value better-lower" id="standardDev">-</span>
                </div>
            </div>

            <div class="metrics-section">
                <h4>Manhattan Distance Evaluation</h4>
                <div class="metric-row">
                    <span>Combined Score:</span>
                    <span class="metric-value better-higher" id="fastCombinedScore">-</span>
                </div>
                <div class="metric-row">
                    <span>Viable Moves:</span>
                    <span class="metric-value better-higher" id="fastViableMoves">-</span>
                </div>
                <div class="metric-row">
                    <span>Standard Deviation:</span>
                    <span class="metric-value better-lower" id="fastStandardDev">-</span>
                </div>
            </div>
        </div>

        <div class="board-card">
            <div id="board2Display" class="board-display"></div>
        </div>

        <div class="status-card">
            <div class="meta-stats">
                <div class="status-row">
                    <span class="status-label">Time Elapsed:</span>
                    <span class="status-value" id="timeElapsed">0.00s</span>
                </div>
                <div class="status-row">
                    <span class="status-label">Boards Evaluated:</span>
                    <span class="status-value" id="boardsEvaluated">0</span>
                </div>
                <div class="status-row">
                    <span class="status-label">Boards/Second:</span>
                    <span class="status-value" id="boardsPerSecond">0.00</span>
                </div>
            </div>
        </div>

        <div class="code-card">
            <pre id="results"></pre>
        </div>

        <div class="copy-card">
            <button class="copy-button" onclick="copyBoardOutput()">ðŸ“‹ Copy Code</button>
        </div>
    </div>

    <script type="module">
        import BOARD_LAYOUTS from './boards.js';

        let WORKER_COUNT = 14; // Default value
        const POPULATION_SIZE = 100;

        let running = false;
        let clockInterval = null;
        let startTime = 0;

        let globalBestScore = -Infinity;
        let globalBestB1 = null;
        let globalBestB2 = null;
        let globalBestStats = null;
        let globalFastStats = null;
        let totalBoardsEvaluated = 0;
        let workers = [];
        let workerCounts = new Array(WORKER_COUNT).fill(0);

        // Gather unique board sizes
        const uniqueSizes = [...new Set(
            Object.values(BOARD_LAYOUTS).map(layout => layout.grid.length)
        )].sort((a, b) => a - b);

        const sizeSelect = document.getElementById('sizeSelect');
        uniqueSizes.forEach(size => {
            const option = document.createElement('option');
            option.value = size;
            option.textContent = `${size}x${size}`;
            if (size === 7) option.selected = true;
            sizeSelect.appendChild(option);
        });

        function updateBoardOptions() {
            const size = parseInt(sizeSelect.value);
            const boardSelect = document.getElementById('boardSelect');
            boardSelect.innerHTML = '<option value="none">None</option>';
            Object.entries(BOARD_LAYOUTS).forEach(([id, layout]) => {
                if (layout.grid.length === size && !id.toLowerCase().includes('random')) {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = layout.name;
                    if (id === 'donut1') option.selected = true;
                    boardSelect.appendChild(option);
                }
            });
        }

        sizeSelect.addEventListener('change', updateBoardOptions);
        updateBoardOptions();

        function cyrb53(str, seed = 0) {
            let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^
                Math.imul(h2 ^ (h2 >>> 13), 3266489909);
            h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^
                Math.imul(h1 ^ (h1 >>> 13), 3266489909);
            return (4294967296 * (2097151 & h2) + (h1 >>> 0)) >>> 0;
        }

        const unifiedWorkerScript = `
// Cache for path calculations with strict size limits
const MAX_CACHE_SIZE = 1000; // Reduced from 10000
const pathCache = new Map();

// More efficient cache key generation
function getBoardKey(grid, startRow, startCol) {
    // Only include the relevant quadrant of the board to reduce key size
    const size = Math.sqrt(grid.length);
    const radius = 3; // Only cache paths within reasonable distance
    const minRow = Math.max(0, startRow - radius);
    const maxRow = Math.min(size - 1, startRow + radius);
    const minCol = Math.max(0, startCol - radius);
    const maxCol = Math.min(size - 1, startCol + radius);
    
    let key = startRow + "," + startCol + ":";
    for (let r = minRow; r <= maxRow; r++) {
        for (let c = minCol; c <= maxCol; c++) {
            const idx = r * size + c;
            key += grid[idx];
        }
    }
    return key;
}

// Cache cleanup that runs more frequently
function cleanupCache() {
    if (pathCache.size > MAX_CACHE_SIZE) {
        const entries = Array.from(pathCache.entries());
        // Keep only 25% of entries to be more aggressive with cleanup
        const toKeep = entries.slice(0, MAX_CACHE_SIZE / 4);
        pathCache.clear();
        toKeep.forEach(([key, value]) => pathCache.set(key, value));
    }
}

// BFS pathfinding with optimized memory usage
function findShortestPath(startRow, startCol, grid) {
    const size = Math.sqrt(grid.length);
    const cacheKey = getBoardKey(grid, startRow, startCol);
    
    if (pathCache.has(cacheKey)) {
        return pathCache.get(cacheKey);
    }
    
    // Use Uint8Array for distances to reduce memory usage
    const distances = new Uint8Array(size * size).fill(255); // 255 represents Infinity
    const queue = [[startRow * size + startCol, 0]];
    distances[startRow * size + startCol] = 0;
    
    while (queue.length > 0) {
        const [curPos, dist] = queue.shift();
        if (dist >= 255) break; // Prevent overflow
        
        const row = Math.floor(curPos / size);
        const col = curPos % size;
        
        const moves = [
            [row - 1, col],
            [row + 1, col],
            [row, col - 1],
            [row, col + 1]
        ];
        
        for (const [newRow, newCol] of moves) {
            if (newRow < 0 || newRow >= size || newCol < 0 || newCol >= size) continue;
            const newPos = newRow * size + newCol;
            if (grid[newPos] === '.' || distances[newPos] !== 255) continue;
            distances[newPos] = dist + 1;
            queue.push([newPos, dist + 1]);
        }
    }
    
    // Only cache if we're within our size limit
    if (pathCache.size < MAX_CACHE_SIZE) {
        pathCache.set(cacheKey, distances);
    }
    
    return distances;
}

// Modified tile score calculation to handle Uint8Array distances
function getTilePathScore(pos, grid) {
    const size = Math.sqrt(grid.length);
    if (grid[pos] === '.') return 0;

    const row = Math.floor(pos / size);
    const col = pos % size;
    const distances = findShortestPath(row, col, grid);
    let score = 0;
    let validPaths = 0;

    for (let i = 0; i < grid.length; i++) {
        if (i === pos || grid[i] === '.') continue;
        const distance = distances[i];
        if (distance !== 255) { // 255 is our Infinity
            score += 1 / distance;
            validPaths++;
        }
    }

    const totalTiles = grid.filter(cell => cell !== '.').length - 1;
    if (validPaths < totalTiles) {
        score *= validPaths / totalTiles;
    }

    return score;
}

// Board generation and validation
const getSymbolsForSize = (size) => {
    if (size === 4) return 'ABCDEFGHIJKLMNOP';
    if (size === 5) return 'ABCDEFGHIJKLMNOPQRSTUVWXY';
    if (size === 6) return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    if (size === 7) return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*+-=/?!~';
    return '';
};

let boardSize = 0;
let pinnedBoard = null;
let evolving = false;
let boardsEvaluated = 0;
let bestScore = -Infinity;
let bestB1 = null;
let bestB2 = null;
let bestStats = null;
let population = [];

function isValidBoard(board) {
    if (!board || board.length !== boardSize * boardSize) {
        return false;
    }
    const valid = getSymbolsForSize(boardSize);
    const seen = new Set();
    for (const ch of board) {
        if (ch === '.') continue;
        if (!valid.includes(ch) || seen.has(ch)) {
            return false;
        }
        seen.add(ch);
    }
    return true;
}

function randomFullBoard() {
    const boardLength = boardSize * boardSize;
    const symbols = getSymbolsForSize(boardSize).split('');
    const result = new Array(boardLength).fill('.');
    // Shuffle
    for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
    }
    // Fill
    for (let i = 0; i < boardLength; i++) {
        if (i < symbols.length) result[i] = symbols[i];
    }
    return result;
}

function randomBoardMatchingPinned(pin) {
    const boardLength = boardSize * boardSize;
    const result = [...pin];
    const symbolPositions = [];
    const symbols = [];
    for (let i = 0; i < boardLength; i++) {
        if (pin[i] !== '.') {
            symbolPositions.push(i);
            symbols.push(pin[i]);
        } else {
            result[i] = '.';
        }
    }
    // Shuffle pinned symbols
    for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
    }
    for (let idx = 0; idx < symbolPositions.length; idx++) {
        result[symbolPositions[idx]] = symbols[idx];
    }
    return result;
}

function mutate(board) {
    if (!isValidBoard(board)) return board;
    const copy = [...board];
    const validPos = [];
    for (let i = 0; i < copy.length; i++) {
        if (copy[i] !== '.') validPos.push(i);
    }
    // Swap 2 pairs of symbols
    for (let s = 0; s < 2; s++) {
        const i1 = Math.floor(Math.random() * validPos.length);
        const i2 = Math.floor(Math.random() * validPos.length);
        const pos1 = validPos[i1];
        const pos2 = validPos[i2];
        [copy[pos1], copy[pos2]] = [copy[pos2], copy[pos1]];
    }
    return isValidBoard(copy) ? copy : board;
}

function crossover(b2a, b2b) {
    if (!isValidBoard(b2a) || !isValidBoard(b2b)) return b2a;
    const child = [...b2a];
    const validPositions = child.map((v, i) => (v !== '.' ? i : -1)).filter(i => i !== -1);
    const half = Math.floor(validPositions.length / 2);
    const used = new Set(b2a.filter(v => v !== '.').slice(0, half));
    let added = 0;
    for (const pos of validPositions) {
        if (added >= half) break;
        const symbol = b2b[pos];
        if (symbol === '.' || used.has(symbol)) continue;
        child[pos] = symbol;
        used.add(symbol);
        added++;
    }
    const fullSym = getSymbolsForSize(boardSize).split('');
    const childSymbols = child.filter(ch => ch !== '.');
    const usedAll = new Set(childSymbols);
    const remain = fullSym.filter(ch => !usedAll.has(ch));
    for (const pos of validPositions) {
        if (child[pos] === '.' || !child[pos]) {
            child[pos] = remain.pop() || '.';
        }
    }
    return isValidBoard(child) ? child : b2a;
}

function pickParent(pop) {
    // Weighted pick by (score + 50) to keep positives
    const totalScore = pop.reduce((sum, p) => sum + (p.stats.score + 50), 0);
    let r = Math.random() * totalScore;
    for (const item of pop) {
        r -= (item.stats.score + 50);
        if (r <= 0) return item;
    }
    return pop[pop.length - 1];
}

function insertImmigrants(pop) {
    const count = Math.max(1, Math.floor(pop.length * 0.05));
    for (let i = 0; i < count; i++) {
        const idx = Math.floor(Math.random() * pop.length);
        if (pinnedBoard) {
            // 20% chance to use the pinned board as an immigrant
            const newB2 = Math.random() < 0.2 ? [...pinnedBoard] : randomBoardMatchingPinned(pinnedBoard);
            const stats = evaluateBoardsFast(pinnedBoard, newB2);
            pop[idx] = { board1: pinnedBoard, board2: newB2, stats };
        } else {
            const b1 = randomFullBoard();
            const b2 = randomFullBoard();
            const stats = evaluateBoardsFast(b1, b2);
            pop[idx] = { board1: b1, board2: b2, stats };
        }
    }
    return pop;
}

// Fast Manhattan distance scoring
function getManhattanScore(pos1, pos2, size) {
    const row1 = Math.floor(pos1 / size);
    const col1 = pos1 % size;
    const row2 = Math.floor(pos2 / size);
    const col2 = pos2 % size;
    return 1 / (1 + Math.abs(row1 - row2) + Math.abs(col1 - col2));
}

function getTileManhattanScore(pos, grid) {
    const size = Math.sqrt(grid.length);
    if (grid[pos] === '.') return 0;

    let score = 0;
    for (let i = 0; i < grid.length; i++) {
        if (i === pos || grid[i] === '.') continue;
        score += getManhattanScore(pos, i, size);
    }
    return score;
}

// Fast evaluation for evolution
function evaluateBoardsFast(b1, b2) {
    if (!isValidBoard(b1) || !isValidBoard(b2)) {
        return {
            score: -Infinity,
            moves: 0,
            stdev: 0
        };
    }

    const scores = [];
    for (let i = 0; i < b1.length; i++) {
        const symbol = b1[i];
        if (symbol === '.') continue;
        const j = b2.indexOf(symbol);
        if (j < 0) continue;
        const score1 = getTileManhattanScore(i, b1);
        const score2 = getTileManhattanScore(j, b2);
        scores.push({
            symbol,
            score: score1 + score2
        });
    }

    if (!scores.length) {
        return {
            score: -Infinity,
            moves: 0,
            stdev: 0
        };
    }

    scores.sort((a, b) => b.score - a.score);
    const best = scores[0].score;
    const mean = scores.reduce((sum, s) => sum + s.score, 0) / scores.length;
    const variance = scores.reduce((sum, s) => sum + Math.pow(s.score - mean, 2), 0) / scores.length;
    const stdev = Math.sqrt(variance);
    const epsilon = 1e-10;
    const viableMoves = scores.filter(s => Math.abs(s.score - best) < epsilon).length;

    return {
        score: viableMoves - (stdev * 0.1),
        moves: viableMoves,
        stdev: stdev
    };
}

// Thorough evaluation with pathfinding for final validation
function evaluateBoardsAccurate(b1, b2) {
    if (!isValidBoard(b1) || !isValidBoard(b2)) {
        return {
            score: -Infinity,
            moves: 0,
            stdev: 0
        };
    }

    const scores = [];
    for (let i = 0; i < b1.length; i++) {
        const symbol = b1[i];
        if (symbol === '.') continue;
        const j = b2.indexOf(symbol);
        if (j < 0) continue;
        const score1 = getTilePathScore(i, b1);
        const score2 = getTilePathScore(j, b2);
        scores.push({
            symbol,
            score: score1 + score2
        });
    }

    if (!scores.length) {
        return {
            score: -Infinity,
            moves: 0,
            stdev: 0
        };
    }

    scores.sort((a, b) => b.score - a.score);
    const best = scores[0].score;
    const mean = scores.reduce((sum, s) => sum + s.score, 0) / scores.length;
    const variance = scores.reduce((sum, s) => sum + Math.pow(s.score - mean, 2), 0) / scores.length;
    const stdev = Math.sqrt(variance);
    const epsilon = 1e-10;
    const viableMoves = scores.filter(s => Math.abs(s.score - best) < epsilon).length;

    return {
        score: viableMoves - (stdev * 0.1),
        moves: viableMoves,
        stdev: stdev
    };
}

let generationsSinceValidation = 0;
const VALIDATE_EVERY_N_GENERATIONS = 20; // Increased validation frequency

function evolve() {
    if (!evolving) return;
    for (let g = 0; g < 25; g++) {
        const newPop = [];
        for (let i = 0; i < ${POPULATION_SIZE}; i++) {
            let b1, b2, stats;
            if (pinnedBoard) {
                b1 = [...pinnedBoard];
                const parent1 = pickParent(population);
                const parent2 = pickParent(population);
                const x2 = crossover(parent1.board2, parent2.board2);
                b2 = mutate(x2);
                stats = evaluateBoardsFast(b1, b2);
            } else {
                const p1 = pickParent(population);
                const p2 = pickParent(population);
                const x1 = crossover(p1.board1, p2.board1);
                const x2 = crossover(p1.board2, p2.board2);
                b1 = mutate(x1);
                b2 = mutate(x2);
                stats = evaluateBoardsFast(b1, b2);
            }
            newPop.push({ board1: b1, board2: b2, stats });
            boardsEvaluated++;
            
            // Update best score only if better than current best
            if (stats.score > bestScore * 0.9) { // Check more candidates
                const accurateStats = evaluateBoardsAccurate(b1, b2);
                if (accurateStats.score > bestScore) {
                    bestScore = accurateStats.score;
                    bestStats = accurateStats;
                    bestB1 = b1;
                    bestB2 = b2;
                }
            }
            
            // Cleanup cache more frequently
            if (pathCache.size > MAX_CACHE_SIZE * 0.9) {
                cleanupCache();
            }
        }
        population = insertImmigrants(newPop);
        
        generationsSinceValidation++;
        if (generationsSinceValidation >= VALIDATE_EVERY_N_GENERATIONS) {
            generationsSinceValidation = 0;
            cleanupCache(); // Force cleanup before validation
            // Validate top 10% of population
            const sortedPop = [...population].sort((a, b) => b.stats.score - a.stats.score);
            const topCount = Math.max(1, Math.floor(population.length * 0.1));
            for (let i = 0; i < topCount; i++) {
                const individual = sortedPop[i];
                const accurateStats = evaluateBoardsAccurate(individual.board1, individual.board2);
                if (accurateStats.score > bestScore) {
                    bestScore = accurateStats.score;
                    bestStats = accurateStats;
                    bestB1 = individual.board1;
                    bestB2 = individual.board2;
                }
            }
        }
    }
    
    // Post status
    if (bestScore > -Infinity) {
        postMessage({
            msg: 'progress',
            boardsEvaluated,
            bestScore,
            bestB1,
            bestB2,
            bestStats: {
                score: bestStats.score,
                moves: bestStats.moves,
                stdev: bestStats.stdev
            },
            fastStats: evaluateBoardsFast(bestB1, bestB2)
        });
    } else {
        postMessage({
            msg: 'progress',
            boardsEvaluated
        });
    }

    if (evolving) {
        setTimeout(evolve, 0);
    }
}

onmessage = (e) => {
    const data = e.data;
    if (data.msg === "start") {
        boardSize = data.boardSize;
        pinnedBoard = null;
        if (data.matchBoard && data.matchBoard.length) {
            pinnedBoard = data.matchBoard;
        }
        evolving = true;
        boardsEvaluated = 0;
        bestScore = -Infinity;
        bestB1 = null;
        bestB2 = null;
        bestStats = null;
        population = [];

        // Initialize population
        for (let i = 0; i < ${POPULATION_SIZE}; i++) {
            let b1, b2;
            if (pinnedBoard) {
                b1 = [...pinnedBoard];
                // Add 20% copies of the pinned board as board 2
                b2 = (i < ${POPULATION_SIZE} * 0.2) ? [...pinnedBoard] : randomBoardMatchingPinned(pinnedBoard);
            } else {
                b1 = randomFullBoard();
                b2 = randomFullBoard();
            }
            const stats = evaluateBoardsFast(b1, b2);
            population.push({ board1: b1, board2: b2, stats });
            if (stats.score > bestScore) {
                bestScore = stats.score;
                bestStats = stats;
                bestB1 = b1;
                bestB2 = b2;
            }
        }
        boardsEvaluated = ${POPULATION_SIZE};
        evolve();
    } else if (data.msg === "stop") {
        evolving = false;
    }
};
`;

        const blob = new Blob([unifiedWorkerScript], { type: 'text/javascript' });
        const workerURL = URL.createObjectURL(blob);

        // Add these functions before updateClockOnly
        function findShortestPath(startRow, startCol, grid, blockedPositions = []) {
            const size = Math.sqrt(grid.length);
            const distances = Array(size * size).fill(Infinity);
            distances[startRow * size + startCol] = 0;

            const queue = [[startRow * size + startCol, 0]];
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // up, down, left, right

            while (queue.length > 0) {
                const [curPos, dist] = queue.shift();
                const row = Math.floor(curPos / size);
                const col = curPos % size;

                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow < 0 || newRow >= size || newCol < 0 || newCol >= size) continue;
                    const newPos = newRow * size + newCol;
                    if (grid[newPos] === '.' || distances[newPos] !== Infinity) continue;
                    if (blockedPositions.some(pos => pos.row === newRow && pos.col === newCol)) continue;

                    distances[newPos] = dist + 1;
                    queue.push([newPos, dist + 1]);
                }
            }

            return distances;
        }

        function getTileScore(row, col, grid, blockedPositions = []) {
            const size = Math.sqrt(grid.length);
            if (grid[row * size + col] === '.') return 0;

            const distances = findShortestPath(row, col, grid, blockedPositions);
            let score = 0;
            let validPaths = 0;

            for (let i = 0; i < grid.length; i++) {
                if (i === row * size + col || grid[i] === '.') continue;
                if (blockedPositions.some(pos => pos.row === Math.floor(i / size) && pos.col === i % size)) continue;

                const distance = distances[i];
                if (distance !== Infinity) {
                    score += 1 / distance;
                    validPaths++;
                }
            }

            const totalTiles = grid.filter(cell => cell !== '.').length - 1 - blockedPositions.length;
            if (validPaths < totalTiles) {
                score *= validPaths / totalTiles;
            }

            return score;
        }

        function updateClockOnly() {
            if (!running) return; // no-op if not running
            const now = performance.now();
            const elapsedSec = (now - startTime) / 1000;
            document.getElementById('timeElapsed').textContent = `${elapsedSec.toFixed(2)}s`;
        }

        function updateStatus() {
            const now = performance.now();
            const elapsedSec = (now - startTime) / 1000;
            const boardsPerSec = elapsedSec > 0 ? totalBoardsEvaluated / elapsedSec : 0;

            document.getElementById('timeElapsed').textContent = `${elapsedSec.toFixed(2)}s`;
            document.getElementById('boardsEvaluated').textContent = Math.floor(totalBoardsEvaluated).toLocaleString();
            document.getElementById('boardsPerSecond').textContent = Math.floor(boardsPerSec).toLocaleString();

            if (globalBestStats) {
                document.getElementById('combinedScore').textContent = globalBestStats.score.toFixed(2);
                document.getElementById('viableMoves').textContent = globalBestStats.moves;
                document.getElementById('standardDev').textContent = globalBestStats.stdev.toFixed(2);
            }

            if (globalFastStats) {
                document.getElementById('fastCombinedScore').textContent = globalFastStats.score.toFixed(2);
                document.getElementById('fastViableMoves').textContent = globalFastStats.moves;
                document.getElementById('fastStandardDev').textContent = globalFastStats.stdev.toFixed(2);
            }
        }

        function generateBoardOutput(b1, b2, score, pinnedUsed) {
            const inputStr = b1.join("") + b2.join("") + score.toFixed(4);
            const hashedId = cyrb53(inputStr).toString();
            const size = Math.sqrt(b1.length);
            const now = new Date();
            const dateStr = `${now.getDate().toString().padStart(2, '0')}/${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getFullYear().toString().slice(2)}`;
            const timeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
            let out = "";
            if (!pinnedUsed) {
                out += `board${hashedId}left: {\n`;
                out += `    name: "evo left ${dateStr} ${timeStr} ${hashedId}",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b1.slice(r * size, (r + 1) * size);
                    out += `        [${row.map(x => "'" + x + "'").join(", ")}],\n`;
                }
                out += "    ]\n},\n";
                out += `board${hashedId}right: {\n`;
                out += `    name: "evo right ${dateStr} ${timeStr} ${hashedId}",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b2.slice(r * size, (r + 1) * size);
                    out += `        [${row.map(x => "'" + x + "'").join(", ")}],\n`;
                }
                out += "    ]\n},\n";
            } else {
                out += `board${hashedId}only: {\n`;
                out += `    name: "evo right ${dateStr} ${timeStr} ${hashedId}",\n`;
                out += "    grid: [\n";
                for (let r = 0; r < size; r++) {
                    const row = b2.slice(r * size, (r + 1) * size);
                    out += `        [${row.map(x => "'" + x + "'").join(", ")}],\n`;
                }
                out += "    ]\n},\n";
            }
            return out;
        }

        function formatBoard(board, size) {
            let result = '';
            for (let r = 0; r < size; r++) {
                result += '    ';
                for (let c = 0; c < size; c++) {
                    result += board[r * size + c].padEnd(2);
                }
                result += '\n';
            }
            return result;
        }

        function getScoreColor(score, minScore, maxScore) {
            const ratio = (score - minScore) / (maxScore - minScore);
            return `hsla(210, 100%, ${85 - (ratio * 70)}%, ${0.4 + (ratio * 0.6)})`;
        }

        function createBoardDisplay(board, scores, minScore, maxScore) {
            const size = Math.sqrt(board.length);
            const container = document.createElement('div');
            container.className = 'board';
            container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;

            // Create a map for O(1) score lookups
            const scoreMap = Object.fromEntries(scores.map(s => [s.symbol, s]));

            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const symbol = board[row * size + col];
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';

                    if (symbol === '.') {
                        cell.style.background = '#f5f5f5';
                    } else {
                        const scoreInfo = scoreMap[symbol];
                        if (scoreInfo) {
                            const combinedScore = scoreInfo.score;
                            const individualScore = scoreInfo.individualScore;
                            cell.style.backgroundColor = getScoreColor(combinedScore, minScore, maxScore);

                            const ratio = (combinedScore - minScore) / (maxScore - minScore);
                            cell.style.color = ratio > 0.5 ? '#fff' : '#000';

                            cell.innerHTML = `
                                <div class="symbol">${symbol}</div>
                                <div class="score">${combinedScore.toFixed(1)}</div>
                                <div class="individual-score">${individualScore.toFixed(1)}</div>
                            `;
                        }
                    }
                    container.appendChild(cell);
                }
            }
            return container;
        }

        let boardHistory = [];
        let currentHistoryIndex = -1;
        let autoFollowLatest = true;

        function addToHistory(state) {
            // Calculate and store min/max scores for this state
            const scores = [];
            const size = Math.sqrt(state.board1.length);
            for (let i = 0; i < state.board1.length; i++) {
                const symbol = state.board1[i];
                if (symbol === '.') continue;
                const j = state.board2.indexOf(symbol);
                if (j < 0) continue;
                scores.push({
                    symbol,
                    score: getTileScore(Math.floor(i / size), i % size, state.board1) +
                        getTileScore(Math.floor(j / size), j % size, state.board2),
                    individualScore: getTileScore(Math.floor(i / size), i % size, state.board1)
                });
            }

            const minScore = Math.min(...scores.map(s => s.score));
            const maxScore = Math.max(...scores.map(s => s.score));

            // Only add if it's better than our previous best
            if (boardHistory.length === 0 || state.score > boardHistory[boardHistory.length - 1].score) {
                boardHistory.push({
                    score: state.score,
                    board1: state.board1,
                    board2: state.board2,
                    stats: state.stats,
                    fastStats: state.fastStats,
                    scores: scores,
                    minScore: minScore,
                    maxScore: maxScore
                });

                // Update navigation
                if (autoFollowLatest) {
                    currentHistoryIndex = boardHistory.length - 1;
                    displayCurrentState();
                }
                updateHistoryControls();
            }
        }

        function updateHistoryControls() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const historyStatus = document.getElementById('historyStatus');

            prevBtn.disabled = currentHistoryIndex <= 0;
            nextBtn.disabled = currentHistoryIndex >= boardHistory.length - 1;

            historyStatus.textContent = boardHistory.length > 0
                ? `${currentHistoryIndex + 1} / ${boardHistory.length} boards`
                : '0 boards';

            // Update auto-follow state
            autoFollowLatest = currentHistoryIndex === boardHistory.length - 1;
        }

        function displayCurrentState() {
            if (currentHistoryIndex < 0 || currentHistoryIndex >= boardHistory.length) return;

            const state = boardHistory[currentHistoryIndex];

            // Update displays
            document.getElementById('combinedScore').textContent = state.stats.score.toFixed(2);
            document.getElementById('viableMoves').textContent = state.stats.moves;
            document.getElementById('standardDev').textContent = state.stats.stdev.toFixed(2);

            if (state.fastStats) {
                document.getElementById('fastCombinedScore').textContent = state.fastStats.score.toFixed(2);
                document.getElementById('fastViableMoves').textContent = state.fastStats.moves;
                document.getElementById('fastStandardDev').textContent = state.fastStats.stdev.toFixed(2);
            }

            const board1Display = document.getElementById('board1Display');
            const board2Display = document.getElementById('board2Display');
            board1Display.innerHTML = '';
            board2Display.innerHTML = '';
            board1Display.appendChild(createBoardDisplay(state.board1, state.scores, state.minScore, state.maxScore));
            board2Display.appendChild(createBoardDisplay(state.board2, state.scores, state.minScore, state.maxScore));

            const pinnedUsed = document.getElementById('boardSelect').value !== 'none';
            document.getElementById('results').textContent = generateBoardOutput(state.board1, state.board2, state.score, pinnedUsed);

            // Update pinned state
            const board1Card = document.getElementById('board1Card');
            board1Card.classList.toggle('pinned', pinnedUsed);
        }

        // Add event listeners for history navigation
        document.getElementById('prevBtn').addEventListener('click', () => {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                displayCurrentState();
                updateHistoryControls();
            }
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            if (currentHistoryIndex < boardHistory.length - 1) {
                currentHistoryIndex++;
                displayCurrentState();
                updateHistoryControls();
            }
        });

        document.getElementById("startBtn").addEventListener("click", () => {
            if (running) return;

            // Update worker count from input
            WORKER_COUNT = parseInt(document.getElementById('workerCount').value) || 14;
            WORKER_COUNT = Math.max(1, Math.min(32, WORKER_COUNT)); // Clamp between 1 and 32
            document.getElementById('workerCount').value = WORKER_COUNT; // Update input with clamped value

            const size = parseInt(sizeSelect.value);
            const boardId = boardSelect.value;
            let matchBoard = null;
            if (boardId !== 'none') {
                matchBoard = [];
                const layout = BOARD_LAYOUTS[boardId].grid;
                for (let i = 0; i < layout.length; i++) {
                    for (let j = 0; j < layout.length; j++) {
                        matchBoard.push(layout[i][j]);
                    }
                }
            }

            running = true;
            startTime = performance.now();
            clockInterval = setInterval(updateClockOnly, 10);

            globalBestScore = -Infinity;
            globalBestB1 = null;
            globalBestB2 = null;
            globalBestStats = null;
            totalBoardsEvaluated = 0;

            // Reset history
            boardHistory = [];
            currentHistoryIndex = -1;
            autoFollowLatest = true;
            updateHistoryControls();

            // Update pinned indicator
            const board1Card = document.getElementById('board1Card');
            board1Card.classList.toggle('pinned', boardId !== 'none');

            // Reset all displays
            document.getElementById('timeElapsed').textContent = '0.00s';
            document.getElementById('boardsEvaluated').textContent = '0';
            document.getElementById('boardsPerSecond').textContent = '0.00';
            document.getElementById('combinedScore').textContent = '-';
            document.getElementById('viableMoves').textContent = '-';
            document.getElementById('standardDev').textContent = '-';
            document.getElementById('fastCombinedScore').textContent = '-';
            document.getElementById('fastViableMoves').textContent = '-';
            document.getElementById('fastStandardDev').textContent = '-';
            document.getElementById('results').textContent = '';
            document.getElementById('board1Display').innerHTML = '';
            document.getElementById('board2Display').innerHTML = '';

            document.getElementById("stopBtn").disabled = false;
            document.getElementById("startBtn").disabled = true;
            workers = [];
            workerCounts = new Array(WORKER_COUNT).fill(0);

            for (let i = 0; i < WORKER_COUNT; i++) {
                const worker = new Worker(workerURL);
                worker.onmessage = (evt) => {
                    const data = evt.data;
                    if (data.msg === "progress") {
                        workerCounts[i] = data.boardsEvaluated;
                        totalBoardsEvaluated = workerCounts.reduce((a, b) => a + b, 0);

                        // Always update the boards evaluated count and time
                        const now = performance.now();
                        const elapsedSec = (now - startTime) / 1000;
                        const boardsPerSec = elapsedSec > 0 ? totalBoardsEvaluated / elapsedSec : 0;
                        document.getElementById('timeElapsed').textContent = `${elapsedSec.toFixed(2)}s`;
                        document.getElementById('boardsEvaluated').textContent = Math.floor(totalBoardsEvaluated).toLocaleString();
                        document.getElementById('boardsPerSecond').textContent = Math.floor(boardsPerSec).toLocaleString();

                        if (data.bestScore > globalBestScore) {
                            globalBestScore = data.bestScore;
                            globalBestB1 = data.bestB1;
                            globalBestB2 = data.bestB2;
                            globalBestStats = data.bestStats;
                            globalFastStats = data.fastStats;

                            // Add to history when we find a better board
                            addToHistory({
                                score: data.bestScore,
                                board1: data.bestB1,
                                board2: data.bestB2,
                                stats: data.bestStats,
                                fastStats: data.fastStats
                            });

                            // Only update the display if we're viewing the latest board
                            if (autoFollowLatest) {
                                displayCurrentState();
                            }
                        }
                    }
                };
                worker.postMessage({
                    msg: "start",
                    boardSize: size,
                    matchBoard: matchBoard
                });
                workers.push(worker);
            }
        });

        document.getElementById("stopBtn").addEventListener("click", () => {
            if (!running) return;
            running = false;

            // Stop the clock timer
            if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }

            for (const worker of workers) {
                worker.postMessage({ msg: "stop" });
            }
            document.getElementById("stopBtn").disabled = true;
            document.getElementById("startBtn").disabled = false;
        });

        // Add the copy functionality
        window.copyBoardOutput = function () {
            const results = document.getElementById('results');
            const button = document.querySelector('.copy-button');

            if (results.textContent) {
                navigator.clipboard.writeText(results.textContent.trimEnd()).then(() => {
                    button.textContent = 'âœ“ Copied!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = 'ðŸ“‹ Copy Code';
                        button.classList.remove('copied');
                    }, 2000);
                });
            }
        };
    </script>
</body>

</html>