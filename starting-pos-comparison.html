<!DOCTYPE html>
<html>

<head>
    <title>Board Starting Position Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 2rem;
            background: #f5f5f5;
            color: #333;
        }

        .controls {
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex-wrap: wrap;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(1, 1fr);
            gap: 1rem;
        }

        .combo-card {
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .analysis-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .board-section {
            display: flex;
            flex-direction: column;
        }

        .section-header {
            margin-bottom: 1rem;
            padding: 1rem;
            background: #f8f8f8;
            border-radius: 4px;
        }

        .section-header h3 {
            margin: 0 0 0.5rem 0;
            color: #333;
        }

        .section-header p {
            margin: 0;
            font-size: 0.9rem;
            color: #666;
        }

        .board-section-title {
            text-align: center;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #666;
        }

        .board-display {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            justify-content: center;
        }

        .board {
            display: grid;
            gap: 1px;
            background: #ddd;
            padding: 1px;
        }

        .board-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            position: relative;
            background: #fff;
        }

        .board-cell .score {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 0.6rem;
            opacity: 0.7;
        }

        .board-cell .move-frequency {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 0.6rem;
            opacity: 0.7;
            color: #d32f2f;
        }

        .metrics {
            margin-bottom: 1rem;
            padding: 0.8rem;
            background: #f8f8f8;
            border-radius: 4px;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }

        .metric-value {
            font-weight: bold;
        }

        .better-lower {
            color: #2196F3;
        }

        .better-higher {
            color: #4CAF50;
        }

        .control-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        select,
        input {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        label {
            font-size: 0.9rem;
        }

        .info-box {
            background: #e3f2fd;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .score-plot,
        .frequency-plot {
            height: 300px;
            margin-top: 1rem;
        }

        .no-data {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            background: #f5f5f5;
            border-radius: 4px;
            color: #666;
            height: 100%;
            text-align: center;
        }

        .no-data-icon {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        .plot-container {
            position: relative;
            width: 100%;
        }
    </style>
</head>

<body>
    <h1>Board Starting Position Analysis</h1>

    <div class="info-box">
        <p>
            Left boards show position scoring: The scoring system evaluates each tile based on its proximity to all
            other tiles.
            Blue intensity indicates better positions, calculated as the sum of inverse Manhattan distances to other
            tiles.
        </p>
        <p>
            Right boards show opening moves: Red intensity shows how frequently each position is chosen as the first
            move in tournament play.
            Percentages indicate the proportion of games where that position was the opening move.
        </p>
        <p><strong>Metrics Explanation:</strong></p>
        <ul>
            <li>
                <strong>Viable Moves:</strong> Count of tiles with scores close to optimal.
                Higher values indicate more good opening options.
            </li>
            <li>
                <strong>Standard Deviation:</strong> Variation in tile scores.
                Lower values indicate more balanced positions.
            </li>
            <li>
                <strong>Best/Worst Ratio:</strong> Ratio between highest and lowest scores.
                Lower values indicate more balanced boards.
            </li>
        </ul>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Board Size:</label>
            <select id="sizeFilter">
                <option value="4">4x4</option>
                <option value="5" selected>5x5</option>
                <option value="6">6x6</option>
                <option value="7">7x7</option>
            </select>
        </div>
        <div class="control-group">
            <label>Board 1:</label>
            <select id="board1Filter"></select>
        </div>
        <div class="control-group">
            <label>Board 2:</label>
            <select id="board2Filter"></select>
        </div>
    </div>
    <div class="analysis-grid" id="analysisGrid"></div>

    <script type="module">
        import BOARD_LAYOUTS from './boards.js';

        async function fetchTournamentData() {
            try {
                const baseUrl = 'https://dbltnk.github.io/entangled/tournaments/';
                const indexResponse = await fetch(baseUrl + 'tournaments.json');
                if (!indexResponse.ok) {
                    throw new Error('Failed to fetch tournament index');
                }
                const tournamentFiles = await indexResponse.json();

                let allFirstMoves = [];
                for (const filename of tournamentFiles) {
                    try {
                        const response = await fetch(baseUrl + filename);
                        if (!response.ok) continue;
                        const data = await response.json();

                        Object.values(data.results).forEach(result => {
                            result.games.forEach(game => {
                                if (game.moves && game.moves.length > 0) {
                                    allFirstMoves.push({
                                        move: game.moves[0],
                                        boards: data.metadata.boards
                                    });
                                }
                            });
                        });
                    } catch (error) {
                        console.warn(`Error processing tournament file ${filename}:`, error);
                    }
                }
                return allFirstMoves;
            } catch (error) {
                console.error('Error fetching tournament data:', error);
                return [];
            }
        }

        function getTileScore(row, col, boardSize) {
            let score = 0;
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (r === row && c === col) continue;
                    const distance = Math.abs(row - r) + Math.abs(col - c);
                    score += 1 / distance;
                }
            }
            return score;
        }

        function findSymbolPosition(symbol, grid) {
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid.length; col++) {
                    if (grid[row][col] === symbol) return { row, col };
                }
            }
            return null;
        }

        function calculateBoardMetrics(scores) {
            scores.sort((a, b) => b.score - a.score);
            const best = scores[0].score;
            const worst = scores[scores.length - 1].score;

            const mean = scores.reduce((sum, s) => sum + s.score, 0) / scores.length;
            const variance = scores.reduce((sum, s) => sum + Math.pow(s.score - mean, 2), 0) / scores.length;
            const stdDev = Math.sqrt(variance);

            const epsilon = 1e-10;
            const viableMoves = scores.filter(s => Math.abs(s.score - best) < epsilon).length;

            return {
                stdDev,
                viableMoves,
                bestWorstRatio: worst / best,
                mean,
                best,
                worst
            };
        }

        function calculateMoveFrequencies(moves, board1Id, board2Id) {
            const filteredMoves = moves.filter(m =>
                m.boards.board1 === board1Id && m.boards.board2 === board2Id
            );

            const frequencies = {};
            filteredMoves.forEach(m => {
                frequencies[m.move] = (frequencies[m.move] || 0) + 1;
            });

            const total = filteredMoves.length || 0;
            if (total === 0) return null;

            return Object.fromEntries(
                Object.entries(frequencies).map(([move, count]) => [
                    move,
                    { count, percentage: (count / total) * 100 }
                ])
            );
        }

        function getScoreColor(score, minScore, maxScore) {
            const ratio = (score - minScore) / (maxScore - minScore);
            return `rgba(33, 150, 243, ${ratio * 0.9})`;
        }

        function getFrequencyColor(percentage) {
            return `rgba(211, 47, 47, ${percentage / 100 * 0.9})`;
        }

        function createScoreBoard(board, scores, minScore, maxScore) {
            const size = board.grid.length;
            const container = document.createElement('div');
            container.className = 'board';
            container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;

            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';
                    const symbol = board.grid[row][col];
                    const score = scores.find(s => s.symbol === symbol).score;
                    cell.style.backgroundColor = getScoreColor(score, minScore, maxScore);
                    cell.style.color = score > (minScore + maxScore) / 2 ? '#fff' : '#000';
                    cell.innerHTML = `${symbol}<span class="score">${score.toFixed(1)}</span>`;
                    cell.style.width = `${40}px`;
                    container.appendChild(cell);
                }
            }
            return container;
        }

        function createFrequencyBoard(board, moveFrequencies) {
            const size = board.grid.length;
            const container = document.createElement('div');
            container.className = 'board';
            container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;

            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';
                    const symbol = board.grid[row][col];
                    const frequency = moveFrequencies[symbol]?.percentage || 0;
                    cell.style.backgroundColor = getFrequencyColor(frequency);
                    cell.style.color = frequency > 50 ? '#fff' : '#000';
                    cell.innerHTML = `${symbol}<span class="move-frequency">${frequency.toFixed(1)}%</span>`;
                    cell.style.width = `${40}px`;
                    container.appendChild(cell);
                }
            }
            return container;
        }

        function createFrequencyPlot(container, moveFrequencies, board1Name, board2Name) {
            const canvas = document.createElement('canvas');
            container.appendChild(canvas);

            if (!moveFrequencies) return;

            const data = Object.entries(moveFrequencies)
                .map(([symbol, data]) => ({
                    symbol,
                    percentage: data.percentage
                }))
                .sort((a, b) => b.percentage - a.percentage);

            const ctx = canvas.getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => d.symbol),
                    datasets: [{
                        data: data.map(d => d.percentage),
                        backgroundColor: 'rgba(211, 47, 47, 0.6)',
                        borderColor: 'rgba(211, 47, 47, 0.8)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false,
                            text: `Move Selection Frequency`
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    return `Selected ${context.formattedValue}% of games`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Selection Frequency (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Symbol'
                            }
                        }
                    }
                }
            });
        }

        function createScatterPlot(container, scores, board1Name, board2Name) {
            const canvas = document.createElement('canvas');
            container.appendChild(canvas);

            scores.sort((a, b) => b.score - a.score);

            const ctx = canvas.getContext('2d');
            new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: scores.map((s, i) => ({
                            x: i,
                            y: s.score,
                            symbol: s.symbol,
                            positions: `${s.board1Pos}, ${s.board2Pos}`
                        })),
                        backgroundColor: 'rgba(33, 150, 243, 0.6)',
                        borderColor: 'rgba(33, 150, 243, 0.8)',
                        borderWidth: 1,
                        pointRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false,
                            text: `${board1Name} vs ${board2Name} (higher is better)`,
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const point = context.raw;
                                    return [
                                        `Symbol: ${point.symbol}`,
                                        `Score: ${point.y.toFixed(1)}`,
                                        `Positions: ${point.positions}`
                                    ];
                                }
                            }
                        },
                        customSymbolLabels: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Position Score',
                            }
                        },
                        x: {
                            ticks: {
                                callback: function (value) {
                                    return scores[value]?.symbol || '';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Symbols (sorted by score)'
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'customSymbolLabels',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const dataset = chart.data.datasets[0];
                        const meta = chart.getDatasetMeta(0);

                        meta.data.forEach((point, index) => {
                            const symbol = dataset.data[index].symbol;
                            const x = point.x;
                            const y = point.y;
                            const textY = y < chart.scales.y.min ? y + 10 : y - 10;

                            ctx.font = '12px Arial';
                            ctx.fillStyle = 'black';
                            ctx.textAlign = 'center';
                            ctx.fillText(symbol, x, textY);
                        });
                    }
                }]
            });
        }

        let globalFirstMoves = [];

        async function initializeData() {
            globalFirstMoves = await fetchTournamentData();
            updateDisplay();
        }

        function updateDisplay() {
            const size = parseInt(document.getElementById('sizeFilter').value);
            const board1Id = document.getElementById('board1Filter').value;
            const board2Id = document.getElementById('board2Filter').value;

            const grid = document.getElementById('analysisGrid');
            grid.innerHTML = '';

            const validBoards = Object.entries(BOARD_LAYOUTS).filter(([id, layout]) =>
                layout.grid.length === size && !id.includes('random') && !id.includes('Random'));

            // Update board filters
            const board1Filter = document.getElementById('board1Filter');
            const board2Filter = document.getElementById('board2Filter');
            const currentBoard1 = board1Filter.value;
            const currentBoard2 = board2Filter.value;

            const options = '<option value="all">All</option>' +
                validBoards.map(([id, board]) =>
                    `<option value="${id}">${board.name}</option>`).join('');
            board1Filter.innerHTML = options;
            board2Filter.innerHTML = options;

            // Change to set board1 as default for 5x5
            if (size === 5 && !currentBoard1) {
                board1Filter.value = 'board1';
            } else if (validBoards.some(([id]) => id === currentBoard1)) {
                board1Filter.value = currentBoard1;
            }
            if (validBoards.some(([id]) => id === currentBoard2)) {
                board2Filter.value = currentBoard2;
            }

            // Replace the boardPairs creation section in updateDisplay()
            let boardPairs = [];
            if (board1Id === 'all' && board2Id === 'all') {
                // Show all combinations
                boardPairs = validBoards.flatMap(board1 =>
                    validBoards.map(board2 => [board1, board2])
                );
            } else if (board1Id === 'all') {
                // Filter only board2
                const board2 = validBoards.find(([id]) => id === board2Id);
                if (board2) {
                    boardPairs = validBoards.map(board1 => [board1, board2]);
                }
            } else if (board2Id === 'all') {
                // Filter only board1
                const board1 = validBoards.find(([id]) => id === board1Id);
                if (board1) {
                    boardPairs = validBoards.map(board2 => [board1, board2]);
                }
            } else {
                // Filter both boards
                const board1 = validBoards.find(([id]) => id === board1Id);
                const board2 = validBoards.find(([id]) => id === board2Id);
                if (board1 && board2) {
                    boardPairs = [[board1, board2]];
                }
            }

            // Ensure we have valid pairs before continuing
            if (boardPairs.length === 0) {
                boardPairs = validBoards.flatMap(board1 =>
                    validBoards.map(board2 => [board1, board2])
                );
            }

            boardPairs
                .map(([[id1, board1], [id2, board2]]) => {
                    if (!board1 || !board2) return null;

                    const scores = analyzeBoards(board1, board2);
                    const metrics = calculateBoardMetrics(scores);
                    const moveFrequencies = calculateMoveFrequencies(globalFirstMoves, id1, id2);

                    return { board1, board2, id1, id2, scores, metrics, moveFrequencies };
                })
                .filter(analysis => analysis !== null)
                .sort((a, b) => b.metrics.viableMoves - a.metrics.viableMoves)
                .forEach(({ board1, board2, id1, id2, scores, metrics, moveFrequencies }) => {
                    const card = document.createElement('div');
                    card.className = 'combo-card';
                    card.innerHTML = `
                        <h2>${board1.name} vs ${board2.name}</h2>
                    `;

                    // Create the analysis container
                    const analysisContainer = document.createElement('div');
                    analysisContainer.className = 'analysis-container';

                    // Create left section (scores + metrics)
                    const scoreSection = document.createElement('div');
                    scoreSection.className = 'board-section';

                    // Add title section for scores
                    const scoreHeader = document.createElement('div');
                    scoreHeader.className = 'section-header';
                    scoreHeader.innerHTML = `
                        <h3>Position Analysis</h3>
                        <p>Blue intensity shows positional strength based on connectivity to other positions.</p>
                    `;
                    scoreSection.appendChild(scoreHeader);

                    // Add metrics to score section
                    const metricsDiv = document.createElement('div');
                    metricsDiv.className = 'metrics';
                    metricsDiv.innerHTML = `
                        <div class="metric-row">
                            <span>Viable Moves (higher = more good options):</span>
                            <span class="metric-value better-higher">${metrics.viableMoves}</span>
                        </div>
                        <div class="metric-row">
                            <span>Standard Deviation (lower = more balanced):</span>
                            <span class="metric-value better-lower">${metrics.stdDev.toFixed(2)}</span>
                        </div>
                        <div class="metric-row">
                            <span>Best/Worst Ratio (lower = more balanced):</span>
                            <span class="metric-value better-lower">${metrics.bestWorstRatio.toFixed(2)}</span>
                        </div>
                    `;
                    scoreSection.appendChild(metricsDiv);

                    // Add score boards
                    const scoreBoardDisplay = document.createElement('div');
                    scoreBoardDisplay.className = 'board-display';
                    scoreBoardDisplay.appendChild(createScoreBoard(board1, scores, metrics.worst, metrics.best));
                    scoreBoardDisplay.appendChild(createScoreBoard(board2, scores, metrics.worst, metrics.best));
                    scoreSection.appendChild(scoreBoardDisplay);

                    // Add score plot
                    const scorePlot = document.createElement('div');
                    scorePlot.className = 'score-plot';
                    scoreSection.appendChild(scorePlot);
                    createScatterPlot(scorePlot, scores, board1.name, board2.name);

                    // Create right section (move frequencies)
                    const frequencySection = document.createElement('div');
                    frequencySection.className = 'board-section';

                    // Add title section for frequencies
                    const frequencyHeader = document.createElement('div');
                    frequencyHeader.className = 'section-header';
                    frequencyHeader.innerHTML = `
                        <h3>Tournament Play Analysis</h3>
                        <p>Red intensity shows how often each position is selected as the first move.</p>
                    `;
                    frequencySection.appendChild(frequencyHeader);

                    // Add metrics to score section
                    const metricsPlaceholder = document.createElement('div');
                    metricsPlaceholder.className = 'metrics';
                    metricsPlaceholder.innerHTML = `
                        <div class="metric-row">
                            <span>[no metrics available yet]</span>
                        </div>
                        <div class="metric-row">
                            <span>[no metrics available yet]</span>
                        </div>
                        <div class="metric-row">
                            <span>[no metrics available yet]</span>
                        </div>
                    `;
                    frequencySection.appendChild(metricsPlaceholder);

                    if (moveFrequencies && Object.keys(moveFrequencies).length > 0) {
                        const frequencyBoardDisplay = document.createElement('div');
                        frequencyBoardDisplay.className = 'board-display';
                        frequencyBoardDisplay.appendChild(createFrequencyBoard(board1, moveFrequencies));
                        frequencyBoardDisplay.appendChild(createFrequencyBoard(board2, moveFrequencies));
                        frequencySection.appendChild(frequencyBoardDisplay);

                        // Add frequency plot
                        const frequencyPlot = document.createElement('div');
                        frequencyPlot.className = 'frequency-plot';
                        frequencySection.appendChild(frequencyPlot);
                        createFrequencyPlot(frequencyPlot, moveFrequencies, board1.name, board2.name);
                    } else {
                        const noDataDiv = document.createElement('div');
                        noDataDiv.className = 'no-data';
                        noDataDiv.innerHTML = `
                            <div class="no-data-icon">📊</div>
                            <div>No tournament play data available for this board combination</div>
                        `;
                        frequencySection.appendChild(noDataDiv);
                    }

                    analysisContainer.appendChild(scoreSection);
                    analysisContainer.appendChild(frequencySection);
                    card.appendChild(analysisContainer);

                    grid.appendChild(card);
                });
        }

        function analyzeBoards(board1, board2) {
            const size = board1.grid.length;
            const scores = [];

            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const symbol = board1.grid[row][col];
                    const board2Pos = findSymbolPosition(symbol, board2.grid);
                    const score1 = getTileScore(row, col, size);
                    const score2 = getTileScore(board2Pos.row, board2Pos.col, size);

                    scores.push({
                        symbol,
                        board1Pos: `${row},${col}`,
                        board2Pos: `${board2Pos.row},${board2Pos.col}`,
                        score: score1 + score2
                    });
                }
            }

            return scores;
        }

        // Event listeners
        document.getElementById('sizeFilter').addEventListener('change', updateDisplay);
        document.getElementById('board1Filter').addEventListener('change', updateDisplay);
        document.getElementById('board2Filter').addEventListener('change', updateDisplay);

        // Initial display
        initializeData();
    </script>
</body>

</html>