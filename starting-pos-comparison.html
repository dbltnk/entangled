<!DOCTYPE html>
<html>

<head>
    <title>Board Starting Position Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 2rem;
            background: #f5f5f5;
            color: #333;
        }

        .controls {
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex-wrap: wrap;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .combo-card {
            background: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .board-display {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            justify-content: center;
        }

        .board {
            display: grid;
            gap: 1px;
            background: #ddd;
            padding: 1px;
        }

        .board-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            position: relative;
            background: #fff;
        }

        .board-cell .score {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 0.6rem;
            opacity: 0.7;
        }

        .metrics {
            margin-bottom: 1rem;
            padding: 0.8rem;
            background: #f8f8f8;
            border-radius: 4px;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }

        .metric-value {
            font-weight: bold;
        }

        .better-lower {
            color: #2196F3;
        }

        .better-higher {
            color: #4CAF50;
        }

        .control-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        select,
        input {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        label {
            font-size: 0.9rem;
        }

        .info-box {
            background: #e3f2fd;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            line-height: 1.5;
        }
    </style>
</head>

<body>
    <h1>Board Starting Position Analysis</h1>

    <div class="info-box">
        <p>
            The scoring system evaluates each tile based on its proximity to all other tiles on the board. The score for
            a tile is calculated as the sum of the inverses of Manhattan distances to all other tiles. This means that
            closer tiles contribute more to the score, and farther tiles contribute less. A higher score indicates a
            better position, where a tile is more favorably placed relative to others.
        </p>
        <p><strong>Metrics Explanation:</strong></p>
        <ul>
            <li>
                <strong>Viable Moves:</strong> This metric counts how many tiles have a score close to the best score
                (highest). Higher values indicate more options for opening moves with similarly strong positions.
            </li>
            <li>
                <strong>Standard Deviation:</strong> This measures the variation in tile scores. A lower standard
                deviation means that scores are more balanced, and no single position is overwhelmingly better than
                others.
            </li>
            <li>
                <strong>Best/Worst Ratio:</strong> This is the ratio of the highest score (best position) to the lowest
                score (worst position). A lower ratio indicates a more balanced board, where no single position
                dominates.
            </li>
        </ul>
        <p>
            By analyzing these metrics, you can evaluate board setups to identify balanced starting positions and
            optimal opening strategies.
        </p>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Board Size:</label>
            <select id="sizeFilter">
                <option value="4">4x4</option>
                <option value="5" selected>5x5</option>
                <option value="6">6x6</option>
                <option value="7">7x7</option>
            </select>
        </div>
        <div class="control-group">
            <label>Board 1:</label>
            <select id="board1Filter"></select>
        </div>
        <div class="control-group">
            <label>Board 2:</label>
            <select id="board2Filter"></select>
        </div>
    </div>
    <div class="analysis-grid" id="analysisGrid"></div>

    <script type="module">
        import BOARD_LAYOUTS from './boards.js';

        function getTileScore(row, col, boardSize) {
            let score = 0;
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (r === row && c === col) continue; // Skip the tile itself
                    const distance = Math.abs(row - r) + Math.abs(col - c);
                    score += 1 / distance;
                }
            }
            return score;
        }

        function findSymbolPosition(symbol, grid) {
            for (let row = 0; row < grid.length; row++) {
                for (let col = 0; col < grid.length; col++) {
                    if (grid[row][col] === symbol) return { row, col };
                }
            }
            return null;
        }

        function calculateBoardMetrics(scores) {
            scores.sort((a, b) => b.score - a.score); // Higher is better
            const best = scores[0].score; // Strictly highest score
            const worst = scores[scores.length - 1].score;

            const mean = scores.reduce((sum, s) => sum + s.score, 0) / scores.length;
            const variance = scores.reduce((sum, s) => sum + Math.pow(s.score - mean, 2), 0) / scores.length;
            const stdDev = Math.sqrt(variance);

            // Use a small epsilon to account for floating-point precision issues
            const epsilon = 1e-10;
            const viableMoves = scores.filter(s => Math.abs(s.score - best) < epsilon).length;

            const bestWorstRatio = worst / best;

            return {
                stdDev,
                viableMoves,
                bestWorstRatio,
                mean,
                best,
                worst
            };
        }

        function getScoreColor(score, minScore, maxScore) {
            const ratio = (score - maxScore) / (minScore - maxScore);
            return `rgba(33, 150, 243, ${ratio * 0.9})`; // Light to dark blue
        }

        function createBoardDisplay(board, scores, minScore, maxScore) {
            const size = board.grid.length;
            const container = document.createElement('div');
            container.className = 'board';
            container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;

            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';
                    const symbol = board.grid[row][col];
                    const score = scores.find(s => s.symbol === symbol).score;
                    cell.style.backgroundColor = getScoreColor(score, minScore, maxScore);
                    cell.style.color = score > (minScore + maxScore) / 2 ? '#fff' : '#000';
                    cell.innerHTML = `${symbol}<span class="score">${score.toFixed(1)}</span>`;
                    cell.style.width = `${40}px`;
                    container.appendChild(cell);
                }
            }
            return container;
        }

        function createScatterPlot(container, scores, board1Name, board2Name) {
            const canvas = document.createElement('canvas');
            container.appendChild(canvas);

            // Sort scores for display (higher is better)
            scores.sort((a, b) => b.score - a.score);

            const ctx = canvas.getContext('2d');
            new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: scores.map((s, i) => ({
                            x: i,
                            y: s.score,
                            symbol: s.symbol,
                            positions: `${s.board1Pos}, ${s.board2Pos}`
                        })),
                        backgroundColor: 'rgba(33, 150, 243, 0.6)',
                        borderColor: 'rgba(33, 150, 243, 0.8)',
                        borderWidth: 1,
                        pointRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false,
                            text: `${board1Name} vs ${board2Name} (higher is better)`,
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const point = context.raw;
                                    return [
                                        `Symbol: ${point.symbol}`,
                                        `Score: ${point.y.toFixed(1)}`,
                                        `Positions: ${point.positions}`
                                    ];
                                }
                            }
                        },
                        customSymbolLabels: {
                            display: true
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Distance Score (higher = better)',
                            }
                        },
                        x: {
                            ticks: {
                                callback: function (value) {
                                    return scores[value]?.symbol || '';
                                }
                            },
                            title: {
                                display: true,
                                text: 'Symbols (sorted by score)'
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'customSymbolLabels',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const dataset = chart.data.datasets[0];
                        const meta = chart.getDatasetMeta(0);

                        meta.data.forEach((point, index) => {
                            const symbol = dataset.data[index].symbol;
                            const x = point.x;
                            const y = point.y;
                            const textY = y < chart.scales.y.min ? y + 10 : y - 10;

                            ctx.font = '12px Arial';
                            ctx.fillStyle = 'black';
                            ctx.textAlign = 'center';
                            ctx.fillText(symbol, x, textY);
                        });
                    }
                }]
            });
        }

        function analyzeBoards(board1, board2) {
            const size = board1.grid.length;
            const scores = [];

            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const symbol = board1.grid[row][col];
                    const board2Pos = findSymbolPosition(symbol, board2.grid);
                    const score1 = getTileScore(row, col, size);
                    const score2 = getTileScore(board2Pos.row, board2Pos.col, size);

                    scores.push({
                        symbol,
                        board1Pos: `${row},${col}`,
                        board2Pos: `${board2Pos.row},${board2Pos.col}`,
                        score: score1 + score2
                    });
                }
            }

            return scores;
        }

        function updateDisplay() {
            const size = parseInt(document.getElementById('sizeFilter').value);
            const board1Id = document.getElementById('board1Filter').value;
            const board2Id = document.getElementById('board2Filter').value;

            const grid = document.getElementById('analysisGrid');
            grid.innerHTML = '';

            const validBoards = Object.entries(BOARD_LAYOUTS).filter(([id, layout]) =>
                layout.grid.length === size && !id.includes('random') && !id.includes('Random'));

            // Update board filters
            const board1Filter = document.getElementById('board1Filter');
            const board2Filter = document.getElementById('board2Filter');
            const currentBoard1 = board1Filter.value;
            const currentBoard2 = board2Filter.value;

            const options = '<option value="all">All</option>' +
                validBoards.map(([id, board]) =>
                    `<option value="${id}">${board.name}</option>`).join('');
            board1Filter.innerHTML = options;
            board2Filter.innerHTML = options;

            // Restore selections if they're still valid for this size
            if (validBoards.some(([id]) => id === currentBoard1)) {
                board1Filter.value = currentBoard1;
            }
            if (validBoards.some(([id]) => id === currentBoard2)) {
                board2Filter.value = currentBoard2;
            }

            // Generate board pairs
            let boardPairs = (board1Id && board2Id && board1Id !== 'all' && board2Id !== 'all') ?
                [[
                    validBoards.find(([id]) => id === board1Id),
                    validBoards.find(([id]) => id === board2Id)
                ]] :
                validBoards.flatMap(board1 =>
                    validBoards.map(board2 => [board1, board2])
                );

            // Analyze and sort by number of options
            const analyses = boardPairs
                .map(([[id1, board1], [id2, board2]]) => {
                    if (!board1 || !board2) {
                        console.log(`Skipping invalid pair: ${id1}, ${id2}`);
                        return null;
                    }

                    const scores = analyzeBoards(board1, board2);
                    const metrics = calculateBoardMetrics(scores);

                    return { board1, board2, scores, metrics };
                })
                .filter(analysis => analysis !== null) // Remove null entries
                .sort((a, b) => b.metrics.viableMoves - a.metrics.viableMoves); // Sort descending

            // Display sorted analyses
            analyses.forEach(({ board1, board2, scores, metrics }) => {
                const card = document.createElement('div');
                card.className = 'combo-card';

                const metricsDiv = document.createElement('div');
                metricsDiv.className = 'metrics';
                metricsDiv.innerHTML = `
                    <h4>${board1.name} vs ${board2.name}</h4>
                    <div class="metric-row">
                        <span>Viable Moves (higher = more good options):</span>
                        <span class="metric-value better-higher">${metrics.viableMoves}</span>
                    </div>
                    <div class="metric-row">
                        <span>Standard Deviation (lower = more balanced):</span>
                        <span class="metric-value better-lower">${metrics.stdDev.toFixed(2)}</span>
                    </div>
                   <div class="metric-row">
                        <span>Best/Worst Ratio (lower = more balanced):</span>
                        <span class="metric-value better-lower">${metrics.bestWorstRatio.toFixed(2)}</span>
                    </div>
                `;
                card.appendChild(metricsDiv);

                const boardDisplay = document.createElement('div');
                boardDisplay.className = 'board-display';
                boardDisplay.appendChild(createBoardDisplay(board1, scores, metrics.best, metrics.worst));
                boardDisplay.appendChild(createBoardDisplay(board2, scores, metrics.best, metrics.worst));
                card.appendChild(boardDisplay);

                const plotContainer = document.createElement('div');
                plotContainer.style.height = '300px';
                card.appendChild(plotContainer);
                createScatterPlot(plotContainer, scores, board1.name, board2.name);

                grid.appendChild(card);
            });
        }

        // Event listeners
        document.getElementById('sizeFilter').addEventListener('change', updateDisplay);
        document.getElementById('board1Filter').addEventListener('change', updateDisplay);
        document.getElementById('board2Filter').addEventListener('change', updateDisplay);

        // Initial display
        updateDisplay();
    </script>
</body>

</html>